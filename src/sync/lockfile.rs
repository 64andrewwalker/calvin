//! Lockfile for tracking generated file checksums
//!
//! Implements TD-15: Lockfile system (.promptpack/.calvin.lock)

use std::collections::HashMap;
use std::path::Path;

use serde::{Deserialize, Serialize};

use crate::error::CalvinResult;

/// Calvin lockfile
///
/// Tracks generated file hashes to detect user modifications.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct Lockfile {
    /// Format version for future compatibility
    #[serde(default = "default_version")]
    pub version: u32,
    
    /// Map of file paths to their metadata
    #[serde(default)]
    pub files: HashMap<String, FileEntry>,
}

fn default_version() -> u32 {
    1
}

/// Entry for a tracked file
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileEntry {
    /// SHA-256 hash of file content
    pub hash: String,
    
    /// When the file was last generated (ISO 8601)
    #[serde(default)]
    pub generated_at: Option<String>,
}

impl Lockfile {
    /// Create a new empty lockfile
    pub fn new() -> Self {
        Self {
            version: 1,
            files: HashMap::new(),
        }
    }

    /// Load lockfile from path, or create new if doesn't exist
    pub fn load_or_new<FS: crate::fs::FileSystem + ?Sized>(path: &Path, fs: &FS) -> Self {
        if fs.exists(path) {
            Self::load(path, fs).unwrap_or_default()
        } else {
            Self::new()
        }
    }

    /// Load lockfile from path
    pub fn load<FS: crate::fs::FileSystem + ?Sized>(path: &Path, fs: &FS) -> CalvinResult<Self> {
        let content = fs.read_to_string(path)?;
        let lockfile: Self = toml::from_str(&content)
            .map_err(|e| crate::error::CalvinError::InvalidFrontmatter {
                file: path.to_path_buf(),
                message: e.to_string(),
            })?;
        Ok(lockfile)
    }

    /// Save lockfile to path
    pub fn save<FS: crate::fs::FileSystem + ?Sized>(&self, path: &Path, fs: &FS) -> CalvinResult<()> {
        let content = toml::to_string_pretty(self)
            .map_err(|e| crate::error::CalvinError::InvalidFrontmatter {
                file: path.to_path_buf(),
                message: e.to_string(),
            })?;
        
        // Add header comment
        let full_content = format!(
            "# Auto-generated by Calvin. Do not edit.\n\n{}",
            content
        );
        
        // Ensure parent directory exists
        if let Some(parent) = path.parent() {
            fs.create_dir_all(parent)?;
        }
        
        // Use atomic write via FileSystem
        fs.write_atomic(path, full_content.as_str())
    }

    /// Get hash for a file path
    pub fn get_hash(&self, path: &str) -> Option<&str> {
        self.files.get(path).map(|e| e.hash.as_str())
    }

    /// Set hash for a file path
    pub fn set_hash(&mut self, path: &str, hash: &str) {
        let now = chrono_now();
        self.files.insert(path.to_string(), FileEntry {
            hash: hash.to_string(),
            generated_at: Some(now),
        });
    }

    /// Remove a file entry
    pub fn remove(&mut self, path: &str) {
        self.files.remove(path);
    }

    /// Check if a file is tracked
    pub fn contains(&self, path: &str) -> bool {
        self.files.contains_key(path)
    }

    /// Get all tracked file paths
    pub fn paths(&self) -> impl Iterator<Item = &str> {
        self.files.keys().map(|s| s.as_str())
    }

    /// Simple accessor for entries (used by plan module)
    pub fn get(&self, path: &str) -> Option<&String> {
        self.files.get(path).map(|e| &e.hash)
    }

    /// Expose entries for iteration
    pub fn entries(&self) -> &HashMap<String, FileEntry> {
        &self.files
    }
}

/// Compute a simple hash of content for comparison
pub fn hash_content(content: &str) -> String {
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};
    
    let mut hasher = DefaultHasher::new();
    content.hash(&mut hasher);
    format!("sha256:{:x}", hasher.finish())
}

/// Get current timestamp in ISO 8601 format
fn chrono_now() -> String {
    // Format: YYYY-MM-DDTHH:MM:SSZ (UTC)
    use std::time::SystemTime;
    
    let now = SystemTime::now();
    let duration = now.duration_since(SystemTime::UNIX_EPOCH).unwrap_or_default();
    let secs = duration.as_secs();
    
    // Convert Unix timestamp to ISO 8601
    // Days since epoch, accounting for leap years
    const SECS_PER_MIN: u64 = 60;
    const SECS_PER_HOUR: u64 = 60 * SECS_PER_MIN;
    const SECS_PER_DAY: u64 = 24 * SECS_PER_HOUR;
    
    // Simple conversion - not accounting for leap seconds
    let days = secs / SECS_PER_DAY;
    let remaining = secs % SECS_PER_DAY;
    let hours = remaining / SECS_PER_HOUR;
    let remaining = remaining % SECS_PER_HOUR;
    let minutes = remaining / SECS_PER_MIN;
    let seconds = remaining % SECS_PER_MIN;
    
    // Calculate year, month, day from days since 1970-01-01
    let (year, month, day) = days_to_ymd(days);
    
    format!(
        "{:04}-{:02}-{:02}T{:02}:{:02}:{:02}Z",
        year, month, day, hours, minutes, seconds
    )
}

/// Convert days since Unix epoch to year/month/day
fn days_to_ymd(days: u64) -> (u32, u32, u32) {
    // Days per month (non-leap year)
    const DAYS_IN_MONTH: [u32; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    
    let mut remaining_days = days as i64;
    let mut year = 1970u32;
    
    loop {
        let days_in_year = if is_leap_year(year) { 366 } else { 365 };
        if remaining_days < days_in_year {
            break;
        }
        remaining_days -= days_in_year;
        year += 1;
    }
    
    let mut month = 1u32;
    for (i, &days) in DAYS_IN_MONTH.iter().enumerate() {
        let days_this_month = if i == 1 && is_leap_year(year) { 29 } else { days } as i64;
        if remaining_days < days_this_month {
            break;
        }
        remaining_days -= days_this_month;
        month += 1;
    }
    
    let day = (remaining_days + 1) as u32;
    
    (year, month, day)
}

fn is_leap_year(year: u32) -> bool {
    (year.is_multiple_of(4) && !year.is_multiple_of(100)) || year.is_multiple_of(400)
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_lockfile_new() {
        let lf = Lockfile::new();
        assert_eq!(lf.version, 1);
        assert!(lf.files.is_empty());
    }

    #[test]
    fn test_lockfile_set_get_hash() {
        let mut lf = Lockfile::new();
        lf.set_hash(".claude/settings.json", "sha256:abc123");
        
        assert_eq!(lf.get_hash(".claude/settings.json"), Some("sha256:abc123"));
        assert_eq!(lf.get_hash("nonexistent"), None);
    }

    #[test]
    fn test_lockfile_contains() {
        let mut lf = Lockfile::new();
        lf.set_hash("file.txt", "hash");
        
        assert!(lf.contains("file.txt"));
        assert!(!lf.contains("other.txt"));
    }

    #[test]
    fn test_lockfile_remove() {
        let mut lf = Lockfile::new();
        lf.set_hash("file.txt", "hash");
        lf.remove("file.txt");
        
        assert!(!lf.contains("file.txt"));
    }

    #[test]
    fn test_lockfile_save_load() {
        let dir = tempdir().unwrap();
        let path = dir.path().join(".calvin.lock");
        let fs = crate::fs::LocalFileSystem;
        
        let mut lf = Lockfile::new();
        lf.set_hash(".claude/settings.json", "sha256:abc123");
        lf.set_hash(".cursor/rules/test/RULE.md", "sha256:def456");
        
        lf.save(&path, &fs).unwrap();
        
        assert!(path.exists());
        
        let loaded = Lockfile::load(&path, &fs).unwrap();
        assert_eq!(loaded.get_hash(".claude/settings.json"), Some("sha256:abc123"));
        assert_eq!(loaded.get_hash(".cursor/rules/test/RULE.md"), Some("sha256:def456"));
    }

    #[test]
    fn test_lockfile_load_or_new_missing() {
        let dir = tempdir().unwrap();
        let path = dir.path().join("missing.lock");
        let fs = crate::fs::LocalFileSystem;
        
        let lf = Lockfile::load_or_new(&path, &fs);
        assert!(lf.files.is_empty());
    }

    #[test]
    fn test_lockfile_paths() {
        let mut lf = Lockfile::new();
        lf.set_hash("a.txt", "hash1");
        lf.set_hash("b.txt", "hash2");
        
        let paths: Vec<_> = lf.paths().collect();
        assert_eq!(paths.len(), 2);
        assert!(paths.contains(&"a.txt"));
        assert!(paths.contains(&"b.txt"));
    }

    #[test]
    fn test_lockfile_toml_format() {
        let mut lf = Lockfile::new();
        lf.set_hash("test.txt", "sha256:abc");
        
        let toml = toml::to_string_pretty(&lf).unwrap();
        assert!(toml.contains("version = 1"));
        assert!(toml.contains("[files.\"test.txt\"]"));
        assert!(toml.contains("hash = \"sha256:abc\""));
    }

    #[test]
    fn test_timestamp_iso8601_format() {
        let timestamp = super::chrono_now();
        
        // Should match YYYY-MM-DDTHH:MM:SSZ format
        assert_eq!(timestamp.len(), 20, "Timestamp should be 20 chars: {}", timestamp);
        assert_eq!(&timestamp[4..5], "-");
        assert_eq!(&timestamp[7..8], "-");
        assert_eq!(&timestamp[10..11], "T");
        assert_eq!(&timestamp[13..14], ":");
        assert_eq!(&timestamp[16..17], ":");
        assert_eq!(&timestamp[19..20], "Z");
        
        // Should be a valid year (2020+)
        let year: u32 = timestamp[0..4].parse().unwrap();
        assert!(year >= 2020, "Year should be 2020+: {}", year);
    }
}
