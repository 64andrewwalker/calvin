//! Lockfile for tracking generated file checksums
//!
//! Implements TD-15: Lockfile system (.promptpack/.calvin.lock)

use std::collections::HashMap;
use std::fs;
use std::path::Path;

use serde::{Deserialize, Serialize};

use crate::error::CalvinResult;

/// Calvin lockfile
///
/// Tracks generated file hashes to detect user modifications.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct Lockfile {
    /// Format version for future compatibility
    #[serde(default = "default_version")]
    pub version: u32,
    
    /// Map of file paths to their metadata
    #[serde(default)]
    pub files: HashMap<String, FileEntry>,
}

fn default_version() -> u32 {
    1
}

/// Entry for a tracked file
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileEntry {
    /// SHA-256 hash of file content
    pub hash: String,
    
    /// When the file was last generated (ISO 8601)
    #[serde(default)]
    pub generated_at: Option<String>,
}

impl Lockfile {
    /// Create a new empty lockfile
    pub fn new() -> Self {
        Self {
            version: 1,
            files: HashMap::new(),
        }
    }

    /// Load lockfile from path, or create new if doesn't exist
    pub fn load_or_new(path: &Path) -> Self {
        if path.exists() {
            Self::load(path).unwrap_or_default()
        } else {
            Self::new()
        }
    }

    /// Load lockfile from path
    pub fn load(path: &Path) -> CalvinResult<Self> {
        let content = fs::read_to_string(path)?;
        let lockfile: Self = toml::from_str(&content)
            .map_err(|e| crate::error::CalvinError::InvalidFrontmatter {
                file: path.to_path_buf(),
                message: e.to_string(),
            })?;
        Ok(lockfile)
    }

    /// Save lockfile to path
    pub fn save(&self, path: &Path) -> CalvinResult<()> {
        let content = toml::to_string_pretty(self)
            .map_err(|e| crate::error::CalvinError::InvalidFrontmatter {
                file: path.to_path_buf(),
                message: e.to_string(),
            })?;
        
        // Add header comment
        let full_content = format!(
            "# Auto-generated by Calvin. Do not edit.\n\n{}",
            content
        );
        
        // Ensure parent directory exists
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)?;
        }
        
        // Use atomic write
        crate::sync::writer::atomic_write(path, full_content.as_bytes())
    }

    /// Get hash for a file path
    pub fn get_hash(&self, path: &str) -> Option<&str> {
        self.files.get(path).map(|e| e.hash.as_str())
    }

    /// Set hash for a file path
    pub fn set_hash(&mut self, path: &str, hash: &str) {
        let now = chrono_now();
        self.files.insert(path.to_string(), FileEntry {
            hash: hash.to_string(),
            generated_at: Some(now),
        });
    }

    /// Remove a file entry
    pub fn remove(&mut self, path: &str) {
        self.files.remove(path);
    }

    /// Check if a file is tracked
    pub fn contains(&self, path: &str) -> bool {
        self.files.contains_key(path)
    }

    /// Get all tracked file paths
    pub fn paths(&self) -> impl Iterator<Item = &str> {
        self.files.keys().map(|s| s.as_str())
    }
}

/// Get current timestamp in ISO 8601 format
fn chrono_now() -> String {
    // Simple timestamp without chrono dependency
    // Format: YYYY-MM-DDTHH:MM:SSZ
    use std::time::SystemTime;
    
    let now = SystemTime::now();
    let duration = now.duration_since(SystemTime::UNIX_EPOCH).unwrap_or_default();
    let secs = duration.as_secs();
    
    // Convert to human-readable (simplified)
    format!("{}", secs)
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_lockfile_new() {
        let lf = Lockfile::new();
        assert_eq!(lf.version, 1);
        assert!(lf.files.is_empty());
    }

    #[test]
    fn test_lockfile_set_get_hash() {
        let mut lf = Lockfile::new();
        lf.set_hash(".claude/settings.json", "sha256:abc123");
        
        assert_eq!(lf.get_hash(".claude/settings.json"), Some("sha256:abc123"));
        assert_eq!(lf.get_hash("nonexistent"), None);
    }

    #[test]
    fn test_lockfile_contains() {
        let mut lf = Lockfile::new();
        lf.set_hash("file.txt", "hash");
        
        assert!(lf.contains("file.txt"));
        assert!(!lf.contains("other.txt"));
    }

    #[test]
    fn test_lockfile_remove() {
        let mut lf = Lockfile::new();
        lf.set_hash("file.txt", "hash");
        lf.remove("file.txt");
        
        assert!(!lf.contains("file.txt"));
    }

    #[test]
    fn test_lockfile_save_load() {
        let dir = tempdir().unwrap();
        let path = dir.path().join(".calvin.lock");
        
        let mut lf = Lockfile::new();
        lf.set_hash(".claude/settings.json", "sha256:abc123");
        lf.set_hash(".cursor/rules/test/RULE.md", "sha256:def456");
        
        lf.save(&path).unwrap();
        
        assert!(path.exists());
        
        let loaded = Lockfile::load(&path).unwrap();
        assert_eq!(loaded.get_hash(".claude/settings.json"), Some("sha256:abc123"));
        assert_eq!(loaded.get_hash(".cursor/rules/test/RULE.md"), Some("sha256:def456"));
    }

    #[test]
    fn test_lockfile_load_or_new_missing() {
        let dir = tempdir().unwrap();
        let path = dir.path().join("missing.lock");
        
        let lf = Lockfile::load_or_new(&path);
        assert!(lf.files.is_empty());
    }

    #[test]
    fn test_lockfile_paths() {
        let mut lf = Lockfile::new();
        lf.set_hash("a.txt", "hash1");
        lf.set_hash("b.txt", "hash2");
        
        let paths: Vec<_> = lf.paths().collect();
        assert_eq!(paths.len(), 2);
        assert!(paths.contains(&"a.txt"));
        assert!(paths.contains(&"b.txt"));
    }

    #[test]
    fn test_lockfile_toml_format() {
        let mut lf = Lockfile::new();
        lf.set_hash("test.txt", "sha256:abc");
        
        let toml = toml::to_string_pretty(&lf).unwrap();
        assert!(toml.contains("version = 1"));
        assert!(toml.contains("[files.\"test.txt\"]"));
        assert!(toml.contains("hash = \"sha256:abc\""));
    }
}
