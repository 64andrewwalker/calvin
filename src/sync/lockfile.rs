//! Lockfile for tracking generated file checksums
//!
//! Implements TD-15: Lockfile system (.promptpack/.calvin.lock)

use std::collections::BTreeMap;
use std::path::Path;

use serde::{Deserialize, Serialize};

use crate::error::CalvinResult;

/// Lockfile key namespace.
///
/// This allows a single lockfile to track multiple deployment destinations
/// without key collisions (e.g., `.claude/settings.json` in project vs home).
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LockfileNamespace {
    Project,
    Home,
}

/// Calvin lockfile
///
/// Tracks generated file hashes to detect user modifications.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct Lockfile {
    /// Format version for future compatibility
    #[serde(default = "default_version")]
    pub version: u32,
    
    /// Map of file paths to their metadata
    #[serde(default)]
    pub files: BTreeMap<String, FileEntry>,
}

fn default_version() -> u32 {
    1
}

/// Entry for a tracked file
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileEntry {
    /// SHA-256 hash of file content
    pub hash: String,
}

impl Lockfile {
    /// Create a new empty lockfile
    pub fn new() -> Self {
        Self {
            version: 1,
            files: BTreeMap::new(),
        }
    }

    /// Load lockfile from path, or create new if doesn't exist
    pub fn load_or_new<FS: crate::fs::FileSystem + ?Sized>(path: &Path, fs: &FS) -> Self {
        if fs.exists(path) {
            Self::load(path, fs).unwrap_or_default()
        } else {
            Self::new()
        }
    }

    /// Load lockfile from path
    pub fn load<FS: crate::fs::FileSystem + ?Sized>(path: &Path, fs: &FS) -> CalvinResult<Self> {
        let content = fs.read_to_string(path)?;
        let lockfile: Self = toml::from_str(&content)
            .map_err(|e| crate::error::CalvinError::InvalidFrontmatter {
                file: path.to_path_buf(),
                message: e.to_string(),
            })?;
        Ok(lockfile)
    }

    /// Save lockfile to path
    pub fn save<FS: crate::fs::FileSystem + ?Sized>(&self, path: &Path, fs: &FS) -> CalvinResult<()> {
        let content = toml::to_string_pretty(self)
            .map_err(|e| crate::error::CalvinError::InvalidFrontmatter {
                file: path.to_path_buf(),
                message: e.to_string(),
            })?;
        
        // Add header comment
        let full_content = format!(
            "# Auto-generated by Calvin. Do not edit.\n\n{}",
            content
        );
        
        // Ensure parent directory exists
        if let Some(parent) = path.parent() {
            fs.create_dir_all(parent)?;
        }
        
        // Use atomic write via FileSystem
        fs.write_atomic(path, full_content.as_str())
    }

    /// Get hash for a file path
    pub fn get_hash(&self, path: &str) -> Option<&str> {
        self.files.get(path).map(|e| e.hash.as_str())
    }

    /// Set hash for a file path
    pub fn set_hash(&mut self, path: &str, hash: &str) {
        self.files.insert(path.to_string(), FileEntry {
            hash: hash.to_string(),
        });
    }

    /// Remove a file entry
    pub fn remove(&mut self, path: &str) {
        self.files.remove(path);
    }

    /// Check if a file is tracked
    pub fn contains(&self, path: &str) -> bool {
        self.files.contains_key(path)
    }

    /// Get all tracked file paths
    pub fn paths(&self) -> impl Iterator<Item = &str> {
        self.files.keys().map(|s| s.as_str())
    }

    /// Simple accessor for entries (used by plan module)
    pub fn get(&self, path: &str) -> Option<&String> {
        self.files.get(path).map(|e| &e.hash)
    }

    /// Expose entries for iteration
    pub fn entries(&self) -> &BTreeMap<String, FileEntry> {
        &self.files
    }
}

/// Compute SHA-256 hash of content for comparison
///
/// Returns the hash in format: `sha256:<64 hex digits>`
/// This format is compatible with remote `sha256sum` output.
pub fn hash_content(content: &str) -> String {
    use sha2::{Sha256, Digest};
    
    let hash = Sha256::digest(content.as_bytes());
    format!("sha256:{:x}", hash)
}

/// Build a stable lockfile key for an output path under a given namespace.
///
/// - Explicit home paths (`~/<...>`) always use the `home:` namespace.
/// - Relative paths are keyed under `project:` or `home:` depending on the namespace.
pub fn lockfile_key(namespace: LockfileNamespace, output_path: &Path) -> String {
    let path_str = output_path.display().to_string();
    if path_str == "~" || path_str.starts_with("~/") {
        return format!("home:{path_str}");
    }

    match namespace {
        LockfileNamespace::Project => format!("project:{path_str}"),
        LockfileNamespace::Home => format!("home:~/{path_str}"),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_lockfile_new() {
        let lf = Lockfile::new();
        assert_eq!(lf.version, 1);
        assert!(lf.files.is_empty());
    }

    #[test]
    fn test_lockfile_set_get_hash() {
        let mut lf = Lockfile::new();
        lf.set_hash(".claude/settings.json", "sha256:abc123");
        
        assert_eq!(lf.get_hash(".claude/settings.json"), Some("sha256:abc123"));
        assert_eq!(lf.get_hash("nonexistent"), None);
    }

    #[test]
    fn test_lockfile_contains() {
        let mut lf = Lockfile::new();
        lf.set_hash("file.txt", "hash");
        
        assert!(lf.contains("file.txt"));
        assert!(!lf.contains("other.txt"));
    }

    #[test]
    fn test_lockfile_remove() {
        let mut lf = Lockfile::new();
        lf.set_hash("file.txt", "hash");
        lf.remove("file.txt");
        
        assert!(!lf.contains("file.txt"));
    }

    #[test]
    fn test_lockfile_save_load() {
        let dir = tempdir().unwrap();
        let path = dir.path().join(".calvin.lock");
        let fs = crate::fs::LocalFileSystem;
        
        let mut lf = Lockfile::new();
        lf.set_hash(".claude/settings.json", "sha256:abc123");
        lf.set_hash(".cursor/rules/test/RULE.md", "sha256:def456");
        
        lf.save(&path, &fs).unwrap();
        
        assert!(path.exists());
        
        let loaded = Lockfile::load(&path, &fs).unwrap();
        assert_eq!(loaded.get_hash(".claude/settings.json"), Some("sha256:abc123"));
        assert_eq!(loaded.get_hash(".cursor/rules/test/RULE.md"), Some("sha256:def456"));
    }

    #[test]
    fn test_lockfile_load_or_new_missing() {
        let dir = tempdir().unwrap();
        let path = dir.path().join("missing.lock");
        let fs = crate::fs::LocalFileSystem;
        
        let lf = Lockfile::load_or_new(&path, &fs);
        assert!(lf.files.is_empty());
    }

    #[test]
    fn test_lockfile_paths() {
        let mut lf = Lockfile::new();
        lf.set_hash("a.txt", "hash1");
        lf.set_hash("b.txt", "hash2");
        
        let paths: Vec<_> = lf.paths().collect();
        assert_eq!(paths.len(), 2);
        assert!(paths.contains(&"a.txt"));
        assert!(paths.contains(&"b.txt"));
    }

    #[test]
    fn test_lockfile_toml_format() {
        let mut lf = Lockfile::new();
        lf.set_hash("test.txt", "sha256:abc");
        
        let toml = toml::to_string_pretty(&lf).unwrap();
        assert!(toml.contains("version = 1"));
        assert!(toml.contains("[files.\"test.txt\"]"));
        assert!(toml.contains("hash = \"sha256:abc\""));
    }

    #[test]
    fn lockfile_key_prefixes_project_paths() {
        assert_eq!(
            lockfile_key(LockfileNamespace::Project, Path::new(".claude/settings.json")),
            "project:.claude/settings.json"
        );
    }

    #[test]
    fn lockfile_key_prefixes_home_relative_paths_with_tilde() {
        assert_eq!(
            lockfile_key(LockfileNamespace::Home, Path::new(".claude/settings.json")),
            "home:~/.claude/settings.json"
        );
    }

    #[test]
    fn lockfile_key_keeps_explicit_home_paths() {
        assert_eq!(
            lockfile_key(LockfileNamespace::Project, Path::new("~/.codex/prompts/test.md")),
            "home:~/.codex/prompts/test.md"
        );
    }

    // --- Variants ---

    #[test]
    fn key__absolute_path__uses_namespace() {
        assert_eq!(
            lockfile_key(LockfileNamespace::Project, Path::new("/tmp/foo")),
            "project:/tmp/foo"
        );
        // Note: For Home namespace, it prepends home:~/.
        // This effectively treats the absolute path as "relative to home" in key generation terms, 
        // ensuring uniqueness even if it looks odd.
        assert_eq!(
            lockfile_key(LockfileNamespace::Home, Path::new("/tmp/foo")),
            "home:~//tmp/foo"
        );

    }

    #[test]
    fn key__parent_traversal__is_preserved_in_key() {
        assert_eq!(
            lockfile_key(LockfileNamespace::Project, Path::new("../foo")),
            "project:../foo"
        );
    }

    #[test]
    fn key__empty_path__handled() {
        assert_eq!(
            lockfile_key(LockfileNamespace::Project, Path::new("")),
            "project:"
        );
    }


}
