//! Lockfile for tracking generated file checksums
//!
//! Implements TD-15: Lockfile system (.promptpack/.calvin.lock)
//!
//! ## Migration Status
//!
//! This module provides backward-compatible types for legacy code.
//! For new code, use the domain layer types:
//!
//! - **Domain entity**: `domain::entities::Lockfile` (pure data structure)
//! - **Repository**: `infrastructure::repositories::TomlLockfileRepository` (I/O operations)
//! - **Namespace**: Re-exported from `domain::value_objects::LockfileNamespace`
//! - **Key generation**: Re-exported from `domain::value_objects::lockfile_key`
//!
//! ### Why Two Lockfile Types?
//!
//! - `sync::lockfile::Lockfile`: Serializable struct with embedded I/O methods (legacy)
//! - `domain::entities::Lockfile`: Pure data structure, I/O via `LockfileRepository`
//!
//! The domain version follows hexagonal architecture principles where entities
//! don't have I/O dependencies. The sync version is kept for backward compatibility.

use std::collections::BTreeMap;
use std::path::Path;

use serde::{Deserialize, Serialize};

use crate::error::CalvinResult;

// Re-export domain types for backward compatibility
pub use crate::domain::value_objects::{lockfile_key, LockfileNamespace};

/// Calvin lockfile
///
/// Tracks generated file hashes to detect user modifications.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct Lockfile {
    /// Format version for future compatibility
    #[serde(default = "default_version")]
    pub version: u32,

    /// Map of file paths to their metadata
    #[serde(default)]
    pub files: BTreeMap<String, FileEntry>,
}

fn default_version() -> u32 {
    1
}

/// Entry for a tracked file
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileEntry {
    /// SHA-256 hash of file content
    pub hash: String,
    // Note: scope is encoded in the key prefix (home: or project:)
    // No separate scope field needed - see docs/impl-plan-sc7-scope.md
}

impl Lockfile {
    /// Create a new empty lockfile
    pub fn new() -> Self {
        Self {
            version: 1,
            files: BTreeMap::new(),
        }
    }

    /// Load lockfile from path, or create new if doesn't exist
    pub fn load_or_new<FS: crate::fs::FileSystem + ?Sized>(path: &Path, fs: &FS) -> Self {
        if fs.exists(path) {
            Self::load(path, fs).unwrap_or_default()
        } else {
            Self::new()
        }
    }

    /// Load lockfile from path
    pub fn load<FS: crate::fs::FileSystem + ?Sized>(path: &Path, fs: &FS) -> CalvinResult<Self> {
        let content = fs.read_to_string(path)?;
        let lockfile: Self = toml::from_str(&content).map_err(|e| {
            crate::error::CalvinError::InvalidFrontmatter {
                file: path.to_path_buf(),
                message: e.to_string(),
            }
        })?;
        Ok(lockfile)
    }

    /// Save lockfile to path
    pub fn save<FS: crate::fs::FileSystem + ?Sized>(
        &self,
        path: &Path,
        fs: &FS,
    ) -> CalvinResult<()> {
        let content = toml::to_string_pretty(self).map_err(|e| {
            crate::error::CalvinError::InvalidFrontmatter {
                file: path.to_path_buf(),
                message: e.to_string(),
            }
        })?;

        // Add header comment
        let full_content = format!("# Auto-generated by Calvin. Do not edit.\n\n{}", content);

        // Ensure parent directory exists
        if let Some(parent) = path.parent() {
            fs.create_dir_all(parent)?;
        }

        // Use atomic write via FileSystem
        fs.write_atomic(path, full_content.as_str())
    }

    /// Get hash for a file path
    pub fn get_hash(&self, path: &str) -> Option<&str> {
        self.files.get(path).map(|e| e.hash.as_str())
    }

    /// Set hash for a file path
    pub fn set_hash(&mut self, path: &str, hash: &str) {
        self.files.insert(
            path.to_string(),
            FileEntry {
                hash: hash.to_string(),
            },
        );
    }

    /// Get scope for a file path by parsing the key prefix
    /// Returns "home" or "project" based on the key format
    pub fn get_scope(&self, path: &str) -> Option<&'static str> {
        if self.files.contains_key(path) {
            if path.starts_with("home:") {
                Some("home")
            } else if path.starts_with("project:") {
                Some("project")
            } else {
                None
            }
        } else {
            None
        }
    }

    /// Remove a file entry
    pub fn remove(&mut self, path: &str) {
        self.files.remove(path);
    }

    /// Check if a file is tracked
    pub fn contains(&self, path: &str) -> bool {
        self.files.contains_key(path)
    }

    /// Get all tracked file paths
    pub fn paths(&self) -> impl Iterator<Item = &str> {
        self.files.keys().map(|s| s.as_str())
    }

    /// Simple accessor for entries (used by plan module)
    pub fn get(&self, path: &str) -> Option<&String> {
        self.files.get(path).map(|e| &e.hash)
    }

    /// Expose entries for iteration
    pub fn entries(&self) -> &BTreeMap<String, FileEntry> {
        &self.files
    }
}

/// Compute SHA-256 hash of content for comparison
///
/// Returns the hash in format: `sha256:<64 hex digits>`
/// This format is compatible with remote `sha256sum` output.
///
/// **Migration Note**: Consider using `domain::value_objects::ContentHash::from_content()`
/// for new code.
pub fn hash_content(content: &str) -> String {
    crate::domain::value_objects::ContentHash::from_content(content).to_string()
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_lockfile_new() {
        let lf = Lockfile::new();
        assert_eq!(lf.version, 1);
        assert!(lf.files.is_empty());
    }

    #[test]
    fn test_lockfile_set_get_hash() {
        let mut lf = Lockfile::new();
        lf.set_hash(".claude/settings.json", "sha256:abc123");

        assert_eq!(lf.get_hash(".claude/settings.json"), Some("sha256:abc123"));
        assert_eq!(lf.get_hash("nonexistent"), None);
    }

    #[test]
    fn test_lockfile_contains() {
        let mut lf = Lockfile::new();
        lf.set_hash("file.txt", "hash");

        assert!(lf.contains("file.txt"));
        assert!(!lf.contains("other.txt"));
    }

    #[test]
    fn test_lockfile_remove() {
        let mut lf = Lockfile::new();
        lf.set_hash("file.txt", "hash");
        lf.remove("file.txt");

        assert!(!lf.contains("file.txt"));
    }

    #[test]
    fn test_lockfile_save_load() {
        let dir = tempdir().unwrap();
        let path = dir.path().join(".calvin.lock");
        let fs = crate::infrastructure::fs::LocalFs::new();

        let mut lf = Lockfile::new();
        lf.set_hash(".claude/settings.json", "sha256:abc123");
        lf.set_hash(".cursor/rules/test/RULE.md", "sha256:def456");

        lf.save(&path, &fs).unwrap();

        assert!(path.exists());

        let loaded = Lockfile::load(&path, &fs).unwrap();
        assert_eq!(
            loaded.get_hash(".claude/settings.json"),
            Some("sha256:abc123")
        );
        assert_eq!(
            loaded.get_hash(".cursor/rules/test/RULE.md"),
            Some("sha256:def456")
        );
    }

    #[test]
    fn test_lockfile_load_or_new_missing() {
        let dir = tempdir().unwrap();
        let path = dir.path().join("missing.lock");
        let fs = crate::infrastructure::fs::LocalFs::new();

        let lf = Lockfile::load_or_new(&path, &fs);
        assert!(lf.files.is_empty());
    }

    #[test]
    fn test_lockfile_paths() {
        let mut lf = Lockfile::new();
        lf.set_hash("a.txt", "hash1");
        lf.set_hash("b.txt", "hash2");

        let paths: Vec<_> = lf.paths().collect();
        assert_eq!(paths.len(), 2);
        assert!(paths.contains(&"a.txt"));
        assert!(paths.contains(&"b.txt"));
    }

    #[test]
    fn test_lockfile_toml_format() {
        let mut lf = Lockfile::new();
        lf.set_hash("test.txt", "sha256:abc");

        let toml = toml::to_string_pretty(&lf).unwrap();
        assert!(toml.contains("version = 1"));
        assert!(toml.contains("[files.\"test.txt\"]"));
        assert!(toml.contains("hash = \"sha256:abc\""));
    }

    #[test]
    fn lockfile_key_prefixes_project_paths() {
        assert_eq!(
            lockfile_key(
                LockfileNamespace::Project,
                Path::new(".claude/settings.json")
            ),
            "project:.claude/settings.json"
        );
    }

    #[test]
    fn lockfile_key_prefixes_home_relative_paths_with_tilde() {
        assert_eq!(
            lockfile_key(LockfileNamespace::Home, Path::new(".claude/settings.json")),
            "home:~/.claude/settings.json"
        );
    }

    #[test]
    fn lockfile_key_keeps_explicit_home_paths() {
        assert_eq!(
            lockfile_key(
                LockfileNamespace::Project,
                Path::new("~/.codex/prompts/test.md")
            ),
            "home:~/.codex/prompts/test.md"
        );
    }

    // --- Variants ---

    #[test]
    fn key__absolute_path__uses_namespace() {
        assert_eq!(
            lockfile_key(LockfileNamespace::Project, Path::new("/tmp/foo")),
            "project:/tmp/foo"
        );
        // Note: For Home namespace, it prepends home:~/.
        // This effectively treats the absolute path as "relative to home" in key generation terms,
        // ensuring uniqueness even if it looks odd.
        assert_eq!(
            lockfile_key(LockfileNamespace::Home, Path::new("/tmp/foo")),
            "home:~//tmp/foo"
        );
    }

    #[test]
    fn key__parent_traversal__is_preserved_in_key() {
        assert_eq!(
            lockfile_key(LockfileNamespace::Project, Path::new("../foo")),
            "project:../foo"
        );
    }

    #[test]
    fn key__empty_path__handled() {
        assert_eq!(
            lockfile_key(LockfileNamespace::Project, Path::new("")),
            "project:"
        );
    }

    // --- SC-7 Scope Tracking Tests ---
    // Note: Scope is now inferred from key prefix, not stored separately

    #[test]
    fn get_scope_infers_from_key_prefix() {
        let mut lf = Lockfile::new();
        lf.set_hash("project:test.md", "sha256:abc");
        lf.set_hash("home:~/.claude/test.md", "sha256:def");

        assert_eq!(lf.get_scope("project:test.md"), Some("project"));
        assert_eq!(lf.get_scope("home:~/.claude/test.md"), Some("home"));
        assert_eq!(lf.get_scope("nonexistent"), None);
    }

    #[test]
    fn old_lockfile_format_still_loads() {
        // Old lockfile format (no scope field - which is now the standard)
        let toml_content = r#"
version = 1

[files."home:~/.claude/test.md"]
hash = "sha256:abc123"
"#;
        let lf: Lockfile = toml::from_str(toml_content).unwrap();
        let entry = lf.files.get("home:~/.claude/test.md").unwrap();
        assert_eq!(entry.hash, "sha256:abc123");
        // Scope is inferred from key prefix
        assert_eq!(lf.get_scope("home:~/.claude/test.md"), Some("home"));
    }
}
