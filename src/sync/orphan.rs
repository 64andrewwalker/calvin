//! Orphan file detection and cleanup
//!
//! Detects files that were previously deployed by Calvin but are no longer
//! in the current output set. These "orphan" files may need cleanup.

use std::collections::HashSet;

use super::OutputFile;
use crate::sync::lockfile::{lockfile_key, Lockfile, LockfileNamespace};

/// Calvin file signature patterns
const CALVIN_SIGNATURES: &[&str] = &[
    "Generated by Calvin",
    "<!-- Generated by Calvin",
    "# Auto-generated by Calvin",
];

/// Result of orphan detection
#[derive(Debug, Clone, Default)]
pub struct OrphanDetectionResult {
    /// Files that are in lockfile but not in current outputs (orphans)
    pub orphans: Vec<OrphanFile>,
    /// Files that are still in current outputs (not orphans)
    pub retained: Vec<String>,
}

/// An orphaned file with metadata
#[derive(Debug, Clone)]
pub struct OrphanFile {
    /// Lockfile key (e.g., "home:~/.claude/commands/old.md")
    pub key: String,
    /// Whether the file has Calvin signature (safe to delete)
    pub has_signature: bool,
    /// Whether the file still exists on disk
    pub exists: bool,
}

impl OrphanFile {
    /// Check if this orphan is safe to delete automatically
    pub fn is_safe_to_delete(&self) -> bool {
        self.exists && self.has_signature
    }
}

/// Check if content contains Calvin signature
pub fn has_calvin_signature(content: &str) -> bool {
    CALVIN_SIGNATURES.iter().any(|sig| content.contains(sig))
}

/// Detect orphan files by comparing lockfile entries against current outputs
///
/// # Arguments
/// * `lockfile` - Current lockfile with previously deployed files
/// * `outputs` - Current output files that will be deployed
/// * `namespace` - The namespace to filter lockfile entries (Project or Home)
pub fn detect_orphans(
    lockfile: &Lockfile,
    outputs: &[OutputFile],
    namespace: LockfileNamespace,
) -> OrphanDetectionResult {
    // Build set of current output keys
    let current_keys: HashSet<String> = outputs
        .iter()
        .map(|o| lockfile_key(namespace, o.path()))
        .collect();

    // Determine namespace prefix to filter lockfile entries
    let prefix = match namespace {
        LockfileNamespace::Project => "project:",
        LockfileNamespace::Home => "home:",
    };

    let mut result = OrphanDetectionResult::default();

    for key in lockfile.paths() {
        // Only check entries matching our namespace
        if !key.starts_with(prefix) {
            continue;
        }

        if current_keys.contains(key) {
            result.retained.push(key.to_string());
        } else {
            // This is an orphan - file was previously deployed but not in current outputs
            result.orphans.push(OrphanFile {
                key: key.to_string(),
                has_signature: false, // Will be checked later by caller
                exists: false,        // Will be checked later by caller
            });
        }
    }

    result
}

/// Check orphan files for Calvin signature and existence
///
/// This requires filesystem access to read the actual file content.
pub fn check_orphan_status<FS: crate::fs::FileSystem + ?Sized>(orphan: &mut OrphanFile, fs: &FS) {
    // Extract path from lockfile key
    let path = extract_path_from_key(&orphan.key);

    // Expand ~ to home directory
    let expanded = crate::sync::expand_home_dir(&std::path::PathBuf::from(&path));

    orphan.exists = fs.exists(&expanded);

    if orphan.exists {
        if let Ok(content) = fs.read_to_string(&expanded) {
            orphan.has_signature = has_calvin_signature(&content);
        }
    }
}

/// Extract file path from lockfile key
///
/// Examples:
/// - "home:~/.claude/commands/test.md" -> "~/.claude/commands/test.md"
/// - "project:.cursor/rules/test.md" -> ".cursor/rules/test.md"
pub fn extract_path_from_key(key: &str) -> String {
    if let Some(pos) = key.find(':') {
        key[pos + 1..].to_string()
    } else {
        key.to_string()
    }
}

/// Result of delete_orphans operation
#[derive(Debug, Clone, Default)]
pub struct DeleteResult {
    /// Files that were successfully deleted
    pub deleted: Vec<String>,
    /// Files that were skipped (no signature and not force)
    pub skipped: Vec<String>,
}

/// Delete orphan files
///
/// # Arguments
/// * `orphans` - List of orphan files to consider for deletion
/// * `force` - If true, delete all orphans regardless of signature
/// * `fs` - Filesystem to use for deletion
///
/// # Returns
/// Result containing counts of deleted and skipped files
pub fn delete_orphans<FS: crate::fs::FileSystem + ?Sized>(
    orphans: &[OrphanFile],
    force: bool,
    fs: &FS,
) -> crate::error::CalvinResult<DeleteResult> {
    use std::path::PathBuf;

    let mut result = DeleteResult::default();

    for orphan in orphans {
        // Skip non-existent files
        if !orphan.exists {
            continue;
        }

        // Determine if we should delete
        let should_delete = force || orphan.is_safe_to_delete();

        if should_delete {
            let path_str = extract_path_from_key(&orphan.key);
            let path = PathBuf::from(&path_str);
            let expanded = crate::sync::expand_home_dir(&path);

            // Attempt deletion
            if let Err(e) = fs.remove_file(&expanded) {
                // Log but don't fail - continue with other files
                eprintln!("Warning: Failed to delete {}: {}", expanded.display(), e);
            } else {
                result.deleted.push(orphan.key.clone());
            }
        } else {
            // File exists but no signature - skip
            result.skipped.push(orphan.key.clone());
        }
    }

    Ok(result)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_has_calvin_signature_html_comment() {
        let content = "<!-- Generated by Calvin 0.2.0 (Adapter v1). Source: test.md. DO NOT EDIT. -->\n\n# Test";
        assert!(has_calvin_signature(content));
    }

    #[test]
    fn test_has_calvin_signature_hash_comment() {
        let content = "# Auto-generated by Calvin. Do not edit.\n\nversion = 1";
        assert!(has_calvin_signature(content));
    }

    #[test]
    fn test_has_calvin_signature_no_match() {
        let content = "# My custom file\n\nThis is user content.";
        assert!(!has_calvin_signature(content));
    }

    #[test]
    fn test_detect_orphans_finds_removed_files() {
        let mut lockfile = Lockfile::new();
        lockfile.set_hash("home:~/.claude/commands/old.md", "sha256:abc");
        lockfile.set_hash("home:~/.claude/commands/current.md", "sha256:def");

        let outputs = vec![OutputFile::new(
            PathBuf::from("~/.claude/commands/current.md"),
            "content",
            crate::domain::value_objects::Target::All,
        )];

        let result = detect_orphans(&lockfile, &outputs, LockfileNamespace::Home);

        assert_eq!(result.orphans.len(), 1);
        assert_eq!(result.orphans[0].key, "home:~/.claude/commands/old.md");
        assert_eq!(result.retained.len(), 1);
    }

    #[test]
    fn test_detect_orphans_filters_by_namespace() {
        let mut lockfile = Lockfile::new();
        lockfile.set_hash("home:~/.claude/commands/home.md", "sha256:abc");
        lockfile.set_hash("project:.claude/commands/project.md", "sha256:def");

        let outputs: Vec<OutputFile> = vec![];

        // When checking home namespace, only home entries are orphans
        let result = detect_orphans(&lockfile, &outputs, LockfileNamespace::Home);
        assert_eq!(result.orphans.len(), 1);
        assert!(result.orphans[0].key.starts_with("home:"));

        // When checking project namespace, only project entries are orphans
        let result = detect_orphans(&lockfile, &outputs, LockfileNamespace::Project);
        assert_eq!(result.orphans.len(), 1);
        assert!(result.orphans[0].key.starts_with("project:"));
    }

    #[test]
    fn test_extract_path_from_key() {
        assert_eq!(
            extract_path_from_key("home:~/.claude/commands/test.md"),
            "~/.claude/commands/test.md"
        );
        assert_eq!(
            extract_path_from_key("project:.cursor/rules/test.md"),
            ".cursor/rules/test.md"
        );
    }

    #[test]
    fn test_orphan_is_safe_to_delete() {
        let orphan = OrphanFile {
            key: "home:~/.claude/commands/test.md".to_string(),
            has_signature: true,
            exists: true,
        };
        assert!(orphan.is_safe_to_delete());

        let orphan_no_sig = OrphanFile {
            key: "home:~/.claude/commands/test.md".to_string(),
            has_signature: false,
            exists: true,
        };
        assert!(!orphan_no_sig.is_safe_to_delete());

        let orphan_not_exists = OrphanFile {
            key: "home:~/.claude/commands/test.md".to_string(),
            has_signature: true,
            exists: false,
        };
        assert!(!orphan_not_exists.is_safe_to_delete());
    }

    // TDD: SC-6 delete_orphans tests
    #[test]
    fn delete_orphans_deletes_safe_files_only() {
        use crate::fs::LocalFileSystem;
        use tempfile::tempdir;

        let dir = tempdir().unwrap();
        let safe_file = dir.path().join("safe.md");
        let unsafe_file = dir.path().join("unsafe.md");

        // Create test files
        std::fs::write(&safe_file, "<!-- Generated by Calvin -->").unwrap();
        std::fs::write(&unsafe_file, "User created content").unwrap();

        let orphans = vec![
            OrphanFile {
                key: format!("project:{}", safe_file.display()),
                has_signature: true,
                exists: true,
            },
            OrphanFile {
                key: format!("project:{}", unsafe_file.display()),
                has_signature: false,
                exists: true,
            },
        ];

        let fs = LocalFileSystem;
        let result = delete_orphans(&orphans, false, &fs).unwrap();

        assert_eq!(result.deleted.len(), 1);
        assert_eq!(result.skipped.len(), 1);
        assert!(!safe_file.exists());
        assert!(unsafe_file.exists());
    }

    #[test]
    fn delete_orphans_force_deletes_all() {
        use crate::fs::LocalFileSystem;
        use tempfile::tempdir;

        let dir = tempdir().unwrap();
        let safe_file = dir.path().join("safe.md");
        let unsafe_file = dir.path().join("unsafe.md");

        std::fs::write(&safe_file, "<!-- Generated by Calvin -->").unwrap();
        std::fs::write(&unsafe_file, "User content").unwrap();

        let orphans = vec![
            OrphanFile {
                key: format!("project:{}", safe_file.display()),
                has_signature: true,
                exists: true,
            },
            OrphanFile {
                key: format!("project:{}", unsafe_file.display()),
                has_signature: false,
                exists: true,
            },
        ];

        let fs = LocalFileSystem;
        let result = delete_orphans(&orphans, true, &fs).unwrap();

        assert_eq!(result.deleted.len(), 2);
        assert_eq!(result.skipped.len(), 0);
        assert!(!safe_file.exists());
        assert!(!unsafe_file.exists());
    }

    #[test]
    fn delete_orphans_skips_nonexistent() {
        use crate::fs::LocalFileSystem;

        let orphans = vec![OrphanFile {
            key: "project:/nonexistent/path.md".to_string(),
            has_signature: true,
            exists: false,
        }];

        let fs = LocalFileSystem;
        let result = delete_orphans(&orphans, false, &fs).unwrap();

        // Should skip because exists=false
        assert_eq!(result.deleted.len(), 0);
        assert_eq!(result.skipped.len(), 0); // Not counted as skipped, just ignored
    }

    // ========================================================================
    // SC-7 Scope Isolation Tests
    // These tests verify that orphan detection respects scope boundaries
    // ========================================================================

    #[test]
    fn multi_scope_deploy_no_cross_contamination() {
        let mut lockfile = Lockfile::new();
        // Simulate: project deploy created this
        lockfile.set_hash("project:.claude/commands/local.md", "sha256:abc");
        // Simulate: home deploy created this
        lockfile.set_hash("home:~/.claude/commands/global.md", "sha256:def");

        // Now deploy home again - only home assets in outputs
        let outputs = vec![OutputFile::new(
            PathBuf::from("~/.claude/commands/global.md"),
            "content",
            crate::domain::value_objects::Target::All,
        )];

        let result = detect_orphans(&lockfile, &outputs, LockfileNamespace::Home);

        // home file is retained, not orphaned
        assert_eq!(result.retained.len(), 1);
        assert!(result.retained[0].starts_with("home:"));

        // project file is NOT detected as orphan (scope isolation)
        assert_eq!(result.orphans.len(), 0);
    }

    #[test]
    fn scope_switch_no_cross_contamination() {
        let mut lockfile = Lockfile::new();
        // User previously only used project scope
        lockfile.set_hash("project:.claude/commands/cmd.md", "sha256:abc");
        lockfile.set_hash("project:.cursor/rules/rule.md", "sha256:def");

        // Now user switches to home for the first time
        let outputs = vec![OutputFile::new(
            PathBuf::from("~/.claude/commands/cmd.md"),
            "new content",
            crate::domain::value_objects::Target::All,
        )];

        let result = detect_orphans(&lockfile, &outputs, LockfileNamespace::Home);

        // No orphans - project files should NOT be detected
        assert_eq!(result.orphans.len(), 0);
        // New home file is tracked (but it's not in lockfile yet, so not in retained either)
        // retained only contains files that match current_keys AND are in lockfile
        assert_eq!(result.retained.len(), 0);
    }

    #[test]
    fn same_path_different_scopes_independent() {
        let mut lockfile = Lockfile::new();
        // Same relative path, but different scopes
        lockfile.set_hash("home:~/.claude/commands/shared.md", "sha256:home");
        lockfile.set_hash("project:.claude/commands/shared.md", "sha256:proj");

        // Home deploy with no outputs (simulating file removed)
        let outputs: Vec<OutputFile> = vec![];

        let result = detect_orphans(&lockfile, &outputs, LockfileNamespace::Home);

        // Only home version is orphaned
        assert_eq!(result.orphans.len(), 1);
        assert_eq!(result.orphans[0].key, "home:~/.claude/commands/shared.md");

        // Project version is untouched (verify with project namespace)
        let project_result = detect_orphans(&lockfile, &outputs, LockfileNamespace::Project);
        assert_eq!(project_result.orphans.len(), 1);
        assert_eq!(
            project_result.orphans[0].key,
            "project:.claude/commands/shared.md"
        );
    }

    #[test]
    fn asset_scope_change_creates_orphan() {
        let mut lockfile = Lockfile::new();
        // Asset was previously deployed to project scope
        lockfile.set_hash("project:.claude/commands/test.md", "sha256:old");

        // User changed asset scope to 'user', so it's no longer in project outputs
        // (It would now appear in home outputs instead)
        let project_outputs: Vec<OutputFile> = vec![];

        let result = detect_orphans(&lockfile, &project_outputs, LockfileNamespace::Project);

        // The project version is now an orphan (scope changed)
        assert_eq!(result.orphans.len(), 1);
        assert_eq!(result.orphans[0].key, "project:.claude/commands/test.md");
    }
}
