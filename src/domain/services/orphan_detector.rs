//! Orphan file detection service
//!
//! Detects files that were previously deployed but are no longer in the current outputs.
//! This is a pure domain service - filesystem checks are delegated to callers.

use std::collections::HashSet;

use crate::domain::entities::{Lockfile, OutputFile};
use crate::domain::value_objects::Scope;

/// Calvin file signature patterns for safe deletion
pub const CALVIN_SIGNATURES: &[&str] = &[
    "Generated by Calvin",
    "<!-- Generated by Calvin",
    "# Auto-generated by Calvin",
];

/// Result of orphan detection
#[derive(Debug, Clone, Default, PartialEq)]
pub struct OrphanDetectionResult {
    /// Files that are in lockfile but not in current outputs (orphans)
    pub orphans: Vec<OrphanFile>,
    /// Files that are still in current outputs (not orphans)
    pub retained: Vec<String>,
}

impl OrphanDetectionResult {
    /// Returns true if there are no orphans
    pub fn is_empty(&self) -> bool {
        self.orphans.is_empty()
    }

    /// Get orphan count
    pub fn orphan_count(&self) -> usize {
        self.orphans.len()
    }

    /// Get retained count
    pub fn retained_count(&self) -> usize {
        self.retained.len()
    }
}

/// An orphaned file with metadata
#[derive(Debug, Clone, PartialEq)]
pub struct OrphanFile {
    /// Lockfile key (e.g., "home:~/.claude/commands/old.md")
    pub key: String,
    /// The path portion of the key
    pub path: String,
    /// Whether the file has Calvin signature (safe to delete)
    pub has_signature: bool,
    /// Whether the file still exists on disk
    pub exists: bool,
}

impl OrphanFile {
    /// Create a new orphan file from a lockfile key
    pub fn from_key(key: &str) -> Self {
        Self {
            key: key.to_string(),
            path: extract_path_from_key(key),
            has_signature: false,
            exists: false,
        }
    }

    /// Check if this orphan is safe to delete automatically
    pub fn is_safe_to_delete(&self) -> bool {
        self.exists && self.has_signature
    }

    /// Mark the file as existing with the given signature status
    pub fn with_status(mut self, exists: bool, has_signature: bool) -> Self {
        self.exists = exists;
        self.has_signature = has_signature;
        self
    }
}

/// Extract file path from lockfile key
///
/// Examples:
/// - "home:~/.claude/commands/test.md" -> "~/.claude/commands/test.md"
/// - "project:.cursor/rules/test.md" -> ".cursor/rules/test.md"
pub fn extract_path_from_key(key: &str) -> String {
    if let Some(pos) = key.find(':') {
        key[pos + 1..].to_string()
    } else {
        key.to_string()
    }
}

/// Check if content contains Calvin signature
pub fn has_calvin_signature(content: &str) -> bool {
    CALVIN_SIGNATURES.iter().any(|sig| content.contains(sig))
}

/// Orphan detection service
///
/// This is a pure domain service that detects orphaned files by comparing
/// lockfile entries against current outputs. It has no filesystem dependencies.
pub struct OrphanDetector;

impl OrphanDetector {
    /// Detect orphan files by comparing lockfile entries against current outputs
    ///
    /// # Arguments
    /// * `lockfile` - Current lockfile with previously deployed files
    /// * `outputs` - Current output files that will be deployed
    /// * `scope` - The scope to filter lockfile entries (Project or User)
    ///
    /// # Scope Isolation
    /// Only entries matching the given scope are considered. This ensures
    /// that deploying to one scope doesn't affect files from another scope.
    pub fn detect(
        lockfile: &Lockfile,
        outputs: &[OutputFile],
        scope: Scope,
    ) -> OrphanDetectionResult {
        // Build set of current output keys
        let current_keys: HashSet<String> = outputs
            .iter()
            .map(|o| Lockfile::make_key(scope, &o.path().to_string_lossy()))
            .collect();

        let mut result = OrphanDetectionResult::default();

        // Only check entries matching our scope
        for key in lockfile.keys_for_scope(scope) {
            if current_keys.contains(key) {
                result.retained.push(key.to_string());
            } else {
                // This is an orphan - file was previously deployed but not in current outputs
                result.orphans.push(OrphanFile::from_key(key));
            }
        }

        result
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    // === TDD: OrphanFile ===

    #[test]
    fn orphan_file_from_key_home() {
        let orphan = OrphanFile::from_key("home:~/.claude/commands/test.md");

        assert_eq!(orphan.key, "home:~/.claude/commands/test.md");
        assert_eq!(orphan.path, "~/.claude/commands/test.md");
        assert!(!orphan.exists);
        assert!(!orphan.has_signature);
    }

    #[test]
    fn orphan_file_from_key_project() {
        let orphan = OrphanFile::from_key("project:.claude/rules/test.md");

        assert_eq!(orphan.key, "project:.claude/rules/test.md");
        assert_eq!(orphan.path, ".claude/rules/test.md");
    }

    #[test]
    fn orphan_file_is_safe_to_delete() {
        let orphan = OrphanFile::from_key("home:test.md").with_status(true, true);
        assert!(orphan.is_safe_to_delete());
    }

    #[test]
    fn orphan_file_not_safe_without_signature() {
        let orphan = OrphanFile::from_key("home:test.md").with_status(true, false);
        assert!(!orphan.is_safe_to_delete());
    }

    #[test]
    fn orphan_file_not_safe_if_not_exists() {
        let orphan = OrphanFile::from_key("home:test.md").with_status(false, true);
        assert!(!orphan.is_safe_to_delete());
    }

    // === TDD: extract_path_from_key ===

    #[test]
    fn extract_path_home() {
        assert_eq!(
            extract_path_from_key("home:~/.claude/commands/test.md"),
            "~/.claude/commands/test.md"
        );
    }

    #[test]
    fn extract_path_project() {
        assert_eq!(
            extract_path_from_key("project:.cursor/rules/test.md"),
            ".cursor/rules/test.md"
        );
    }

    #[test]
    fn extract_path_no_prefix() {
        assert_eq!(extract_path_from_key("plain.md"), "plain.md");
    }

    // === TDD: has_calvin_signature ===

    #[test]
    fn signature_html_comment() {
        let content = "<!-- Generated by Calvin 0.2.0 (Adapter v1). Source: test.md. DO NOT EDIT. -->\n\n# Test";
        assert!(has_calvin_signature(content));
    }

    #[test]
    fn signature_hash_comment() {
        let content = "# Auto-generated by Calvin. Do not edit.\n\nversion = 1";
        assert!(has_calvin_signature(content));
    }

    #[test]
    fn signature_plain() {
        let content = "Generated by Calvin version 1.0";
        assert!(has_calvin_signature(content));
    }

    #[test]
    fn signature_not_found() {
        let content = "# My custom file\n\nThis is user content.";
        assert!(!has_calvin_signature(content));
    }

    // === TDD: OrphanDetectionResult ===

    #[test]
    fn result_is_empty() {
        let result = OrphanDetectionResult::default();
        assert!(result.is_empty());
        assert_eq!(result.orphan_count(), 0);
    }

    #[test]
    fn result_counts() {
        let mut result = OrphanDetectionResult::default();
        result.orphans.push(OrphanFile::from_key("home:test.md"));
        result.retained.push("home:kept.md".to_string());

        assert!(!result.is_empty());
        assert_eq!(result.orphan_count(), 1);
        assert_eq!(result.retained_count(), 1);
    }

    // === TDD: OrphanDetector::detect ===

    #[test]
    fn detect_finds_removed_files() {
        let mut lockfile = Lockfile::new();
        lockfile.set("home:~/.claude/commands/old.md", "sha256:abc");
        lockfile.set("home:~/.claude/commands/current.md", "sha256:def");

        let outputs = vec![OutputFile::new(
            PathBuf::from("~/.claude/commands/current.md"),
            "content",
            crate::domain::value_objects::Target::ClaudeCode,
        )];

        let result = OrphanDetector::detect(&lockfile, &outputs, Scope::User);

        assert_eq!(result.orphans.len(), 1);
        assert_eq!(result.orphans[0].key, "home:~/.claude/commands/old.md");
        assert_eq!(result.retained.len(), 1);
    }

    #[test]
    fn detect_filters_by_scope() {
        let mut lockfile = Lockfile::new();
        lockfile.set("home:~/.claude/commands/home.md", "sha256:abc");
        lockfile.set("project:.claude/commands/project.md", "sha256:def");

        let outputs: Vec<OutputFile> = vec![];

        // When checking user/home scope, only home entries are orphans
        let result = OrphanDetector::detect(&lockfile, &outputs, Scope::User);
        assert_eq!(result.orphans.len(), 1);
        assert!(result.orphans[0].key.starts_with("home:"));

        // When checking project scope, only project entries are orphans
        let result = OrphanDetector::detect(&lockfile, &outputs, Scope::Project);
        assert_eq!(result.orphans.len(), 1);
        assert!(result.orphans[0].key.starts_with("project:"));
    }

    // === TDD: SC-7 Scope Isolation Tests ===

    #[test]
    fn multi_scope_deploy_no_cross_contamination() {
        let mut lockfile = Lockfile::new();
        // Simulate: project deploy created this
        lockfile.set("project:.claude/commands/local.md", "sha256:abc");
        // Simulate: home deploy created this
        lockfile.set("home:~/.claude/commands/global.md", "sha256:def");

        // Now deploy home again - only home assets in outputs
        let outputs = vec![OutputFile::new(
            PathBuf::from("~/.claude/commands/global.md"),
            "content",
            crate::domain::value_objects::Target::ClaudeCode,
        )];

        let result = OrphanDetector::detect(&lockfile, &outputs, Scope::User);

        // home file is retained, not orphaned
        assert_eq!(result.retained.len(), 1);
        assert!(result.retained[0].starts_with("home:"));

        // project file is NOT detected as orphan (scope isolation)
        assert_eq!(result.orphans.len(), 0);
    }

    #[test]
    fn scope_switch_no_cross_contamination() {
        let mut lockfile = Lockfile::new();
        // User previously only used project scope
        lockfile.set("project:.claude/commands/cmd.md", "sha256:abc");
        lockfile.set("project:.cursor/rules/rule.md", "sha256:def");

        // Now user switches to home for the first time
        let outputs = vec![OutputFile::new(
            PathBuf::from("~/.claude/commands/cmd.md"),
            "new content",
            crate::domain::value_objects::Target::ClaudeCode,
        )];

        let result = OrphanDetector::detect(&lockfile, &outputs, Scope::User);

        // No orphans - project files should NOT be detected
        assert_eq!(result.orphans.len(), 0);
        // New home file is not in lockfile yet, so not in retained either
        assert_eq!(result.retained.len(), 0);
    }

    #[test]
    fn same_path_different_scopes_independent() {
        let mut lockfile = Lockfile::new();
        // Same relative path, but different scopes
        lockfile.set("home:~/.claude/commands/shared.md", "sha256:home");
        lockfile.set("project:.claude/commands/shared.md", "sha256:proj");

        // Home deploy with no outputs (simulating file removed)
        let outputs: Vec<OutputFile> = vec![];

        let result = OrphanDetector::detect(&lockfile, &outputs, Scope::User);

        // Only home version is orphaned
        assert_eq!(result.orphans.len(), 1);
        assert_eq!(result.orphans[0].key, "home:~/.claude/commands/shared.md");

        // Project version is untouched (verify with project scope)
        let project_result = OrphanDetector::detect(&lockfile, &outputs, Scope::Project);
        assert_eq!(project_result.orphans.len(), 1);
        assert_eq!(
            project_result.orphans[0].key,
            "project:.claude/commands/shared.md"
        );
    }

    #[test]
    fn asset_scope_change_creates_orphan() {
        let mut lockfile = Lockfile::new();
        // Asset was previously deployed to project scope
        lockfile.set("project:.claude/commands/test.md", "sha256:old");

        // User changed asset scope to 'user', so it's no longer in project outputs
        let project_outputs: Vec<OutputFile> = vec![];

        let result = OrphanDetector::detect(&lockfile, &project_outputs, Scope::Project);

        // The project version is now an orphan (scope changed)
        assert_eq!(result.orphans.len(), 1);
        assert_eq!(result.orphans[0].key, "project:.claude/commands/test.md");
    }
}
