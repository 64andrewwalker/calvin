//! Compiler service interfaces
//!
//! Defines the compilation contract - transforming Assets into OutputFiles.
//! Actual compilation strategies are implemented by Adapters in the infrastructure layer.

use crate::domain::entities::OutputFile;
use crate::domain::value_objects::Target;
use std::path::PathBuf;

/// Result of compiling a single asset
#[derive(Debug, Clone, Default)]
pub struct CompilationResult {
    /// Output files generated
    pub outputs: Vec<OutputFile>,
    /// Warnings during compilation
    pub warnings: Vec<String>,
}

impl CompilationResult {
    /// Create a new empty result
    pub fn new() -> Self {
        Self::default()
    }

    /// Create result with single output
    pub fn single(output: OutputFile) -> Self {
        Self {
            outputs: vec![output],
            warnings: Vec::new(),
        }
    }

    /// Create result with multiple outputs
    pub fn many(outputs: Vec<OutputFile>) -> Self {
        Self {
            outputs,
            warnings: Vec::new(),
        }
    }

    /// Add a warning
    pub fn with_warning(mut self, warning: impl Into<String>) -> Self {
        self.warnings.push(warning.into());
        self
    }

    /// Check if empty
    pub fn is_empty(&self) -> bool {
        self.outputs.is_empty()
    }

    /// Number of outputs
    pub fn len(&self) -> usize {
        self.outputs.len()
    }

    /// Has warnings
    pub fn has_warnings(&self) -> bool {
        !self.warnings.is_empty()
    }

    /// Merge another result
    pub fn merge(mut self, other: CompilationResult) -> Self {
        self.outputs.extend(other.outputs);
        self.warnings.extend(other.warnings);
        self
    }
}

/// Generates the standard Calvin footer for output files
pub fn generate_footer(source_path: &str, version: &str) -> String {
    format!(
        "<!-- Generated by Calvin {} (Adapter v1). Source: {}. DO NOT EDIT. -->",
        version, source_path
    )
}

/// Generates a comment-style footer (for non-HTML contexts)
pub fn generate_comment_footer(source_path: &str, version: &str) -> String {
    format!("# Generated by Calvin {}. Source: {}", version, source_path)
}

/// Path computation for different targets and asset kinds
pub struct PathGenerator;

impl PathGenerator {
    /// Get the rules path for a target
    pub fn rules_path(target: Target, asset_id: &str, is_user_scope: bool) -> Option<PathBuf> {
        let base = match target {
            Target::ClaudeCode => {
                if is_user_scope {
                    PathBuf::from("~/.claude")
                } else {
                    PathBuf::from(".claude")
                }
            }
            Target::Cursor => {
                if is_user_scope {
                    PathBuf::from("~/.cursor/rules")
                } else {
                    PathBuf::from(".cursor/rules")
                }
            }
            Target::VSCode => {
                if is_user_scope {
                    PathBuf::from("~/.vscode")
                } else {
                    PathBuf::from(".vscode")
                }
            }
            Target::Antigravity => {
                if is_user_scope {
                    // Gemini doesn't have user-level rules
                    return None;
                }
                PathBuf::from(".gemini")
            }
            Target::Codex => {
                // Codex always writes to home
                PathBuf::from("~/.codex/prompts")
            }
            Target::All => return None, // All is expanded before this
        };

        Some(base.join(format!("{}.md", asset_id)))
    }

    /// Get the commands path for a target
    pub fn commands_path(target: Target, asset_id: &str, is_user_scope: bool) -> Option<PathBuf> {
        match target {
            Target::ClaudeCode => {
                let base = if is_user_scope {
                    PathBuf::from("~/.claude/commands")
                } else {
                    PathBuf::from(".claude/commands")
                };
                Some(base.join(format!("{}.md", asset_id)))
            }
            Target::Cursor => {
                // Cursor uses commands format when Claude Code is not available
                let base = if is_user_scope {
                    PathBuf::from("~/.cursor/commands")
                } else {
                    PathBuf::from(".cursor/commands")
                };
                Some(base.join(format!("{}.md", asset_id)))
            }
            _ => None, // Other targets don't have commands
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // === TDD: CompilationResult ===

    #[test]
    fn result_new_is_empty() {
        let result = CompilationResult::new();
        assert!(result.is_empty());
        assert_eq!(result.len(), 0);
        assert!(!result.has_warnings());
    }

    #[test]
    fn result_single() {
        let output = OutputFile::new("test.md", "content", Target::ClaudeCode);
        let result = CompilationResult::single(output);

        assert!(!result.is_empty());
        assert_eq!(result.len(), 1);
    }

    #[test]
    fn result_many() {
        let outputs = vec![
            OutputFile::new("a.md", "a", Target::ClaudeCode),
            OutputFile::new("b.md", "b", Target::Cursor),
        ];
        let result = CompilationResult::many(outputs);

        assert_eq!(result.len(), 2);
    }

    #[test]
    fn result_with_warning() {
        let result = CompilationResult::new()
            .with_warning("Warning 1")
            .with_warning("Warning 2");

        assert!(result.has_warnings());
        assert_eq!(result.warnings.len(), 2);
    }

    #[test]
    fn result_merge() {
        let r1 = CompilationResult::single(OutputFile::new("a.md", "a", Target::ClaudeCode))
            .with_warning("W1");
        let r2 = CompilationResult::single(OutputFile::new("b.md", "b", Target::Cursor))
            .with_warning("W2");

        let merged = r1.merge(r2);

        assert_eq!(merged.len(), 2);
        assert_eq!(merged.warnings.len(), 2);
    }

    // === TDD: Footer Generation ===

    #[test]
    fn generate_footer_html() {
        let footer = generate_footer("test.md", "0.2.0");
        assert!(footer.contains("Generated by Calvin"));
        assert!(footer.contains("0.2.0"));
        assert!(footer.contains("test.md"));
        assert!(footer.starts_with("<!--"));
    }

    #[test]
    fn generate_footer_comment() {
        let footer = generate_comment_footer("test.md", "0.2.0");
        assert!(footer.starts_with("# Generated by Calvin"));
        assert!(footer.contains("test.md"));
    }

    // === TDD: PathGenerator ===

    #[test]
    fn path_generator_claude_rules_project() {
        let path = PathGenerator::rules_path(Target::ClaudeCode, "test-rule", false);
        assert_eq!(path, Some(PathBuf::from(".claude/test-rule.md")));
    }

    #[test]
    fn path_generator_claude_rules_user() {
        let path = PathGenerator::rules_path(Target::ClaudeCode, "test-rule", true);
        assert_eq!(path, Some(PathBuf::from("~/.claude/test-rule.md")));
    }

    #[test]
    fn path_generator_cursor_rules_project() {
        let path = PathGenerator::rules_path(Target::Cursor, "test-rule", false);
        assert_eq!(path, Some(PathBuf::from(".cursor/rules/test-rule.md")));
    }

    #[test]
    fn path_generator_cursor_rules_user() {
        let path = PathGenerator::rules_path(Target::Cursor, "test-rule", true);
        assert_eq!(path, Some(PathBuf::from("~/.cursor/rules/test-rule.md")));
    }

    #[test]
    fn path_generator_antigravity_project_only() {
        let path = PathGenerator::rules_path(Target::Antigravity, "test-rule", false);
        assert_eq!(path, Some(PathBuf::from(".gemini/test-rule.md")));

        // User scope not supported
        let path = PathGenerator::rules_path(Target::Antigravity, "test-rule", true);
        assert_eq!(path, None);
    }

    #[test]
    fn path_generator_codex_always_home() {
        let path = PathGenerator::rules_path(Target::Codex, "test-rule", false);
        assert_eq!(path, Some(PathBuf::from("~/.codex/prompts/test-rule.md")));

        let path = PathGenerator::rules_path(Target::Codex, "test-rule", true);
        assert_eq!(path, Some(PathBuf::from("~/.codex/prompts/test-rule.md")));
    }

    #[test]
    fn path_generator_all_returns_none() {
        let path = PathGenerator::rules_path(Target::All, "test-rule", false);
        assert_eq!(path, None);
    }

    #[test]
    fn path_generator_claude_commands() {
        let path = PathGenerator::commands_path(Target::ClaudeCode, "my-cmd", false);
        assert_eq!(path, Some(PathBuf::from(".claude/commands/my-cmd.md")));

        let path = PathGenerator::commands_path(Target::ClaudeCode, "my-cmd", true);
        assert_eq!(path, Some(PathBuf::from("~/.claude/commands/my-cmd.md")));
    }

    #[test]
    fn path_generator_cursor_commands() {
        let path = PathGenerator::commands_path(Target::Cursor, "my-cmd", false);
        assert_eq!(path, Some(PathBuf::from(".cursor/commands/my-cmd.md")));
    }

    #[test]
    fn path_generator_no_commands_for_other_targets() {
        assert_eq!(
            PathGenerator::commands_path(Target::VSCode, "cmd", false),
            None
        );
        assert_eq!(
            PathGenerator::commands_path(Target::Antigravity, "cmd", false),
            None
        );
        assert_eq!(
            PathGenerator::commands_path(Target::Codex, "cmd", false),
            None
        );
    }
}
