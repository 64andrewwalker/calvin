//! Compiler service interfaces
//!
//! Defines the compilation contract - transforming Assets into OutputFiles.
//! Actual compilation strategies are implemented by Adapters in the infrastructure layer.

use crate::domain::entities::OutputFile;
use crate::domain::value_objects::Target;
use std::path::PathBuf;

/// Result of compiling a single asset
#[derive(Debug, Clone, Default)]
pub struct CompilationResult {
    /// Output files generated
    pub outputs: Vec<OutputFile>,
    /// Warnings during compilation
    pub warnings: Vec<String>,
}

impl CompilationResult {
    /// Create a new empty result
    pub fn new() -> Self {
        Self::default()
    }

    /// Create result with single output
    pub fn single(output: OutputFile) -> Self {
        Self {
            outputs: vec![output],
            warnings: Vec::new(),
        }
    }

    /// Create result with multiple outputs
    pub fn many(outputs: Vec<OutputFile>) -> Self {
        Self {
            outputs,
            warnings: Vec::new(),
        }
    }

    /// Add a warning
    pub fn with_warning(mut self, warning: impl Into<String>) -> Self {
        self.warnings.push(warning.into());
        self
    }

    /// Check if empty
    pub fn is_empty(&self) -> bool {
        self.outputs.is_empty()
    }

    /// Number of outputs
    pub fn len(&self) -> usize {
        self.outputs.len()
    }

    /// Has warnings
    pub fn has_warnings(&self) -> bool {
        !self.warnings.is_empty()
    }

    /// Merge another result
    pub fn merge(mut self, other: CompilationResult) -> Self {
        self.outputs.extend(other.outputs);
        self.warnings.extend(other.warnings);
        self
    }
}

/// Generates the standard Calvin footer for output files
pub fn generate_footer(source_path: &str, _version: &str) -> String {
    // Note: version parameter kept for API compatibility but not used in output
    // to avoid snapshot test updates on every version bump
    format!(
        "<!-- Generated by Calvin. Source: {}. DO NOT EDIT. -->",
        source_path
    )
}

/// Generates a comment-style footer (for non-HTML contexts)
pub fn generate_comment_footer(source_path: &str, _version: &str) -> String {
    format!("# Generated by Calvin. Source: {}", source_path)
}

/// Path computation for different targets and asset kinds
///
/// This generates platform-agnostic paths using `PathBuf::from()` and `.join()`.
/// The `~/` prefix is expanded at sync time to the user's home directory.
///
/// Cross-platform support:
/// - macOS/Linux: `~/` → `$HOME/`
/// - Windows: `~/` → `%USERPROFILE%\`
pub struct PathGenerator;

impl PathGenerator {
    /// Get the rules/policy path for a target
    ///
    /// # Arguments
    /// * `target` - The target platform
    /// * `asset_id` - The asset identifier (used for filename)
    /// * `is_user_scope` - Whether this is a user-level (global) asset
    ///
    /// # Returns
    /// The path where the rule file should be written, or None if the target
    /// doesn't support rules at this scope.
    pub fn rules_path(target: Target, asset_id: &str, is_user_scope: bool) -> Option<PathBuf> {
        match target {
            Target::ClaudeCode => {
                // Claude Code uses commands for everything, not separate rules
                // But we map policies to commands as well
                let base = if is_user_scope {
                    PathBuf::from("~").join(".claude").join("commands")
                } else {
                    PathBuf::from(".claude").join("commands")
                };
                Some(base.join(format!("{}.md", asset_id)))
            }
            Target::Cursor => {
                // Cursor uses: .cursor/rules/<id>/RULE.md
                let base = if is_user_scope {
                    PathBuf::from("~").join(".cursor").join("rules")
                } else {
                    PathBuf::from(".cursor").join("rules")
                };
                Some(base.join(asset_id).join("RULE.md"))
            }
            Target::VSCode => {
                // VS Code/Copilot uses: .github/instructions/<id>.instructions.md
                // User scope not supported for VS Code
                if is_user_scope {
                    return None;
                }
                let base = PathBuf::from(".github").join("instructions");
                Some(base.join(format!("{}.instructions.md", asset_id)))
            }
            Target::Antigravity => {
                // Antigravity/Gemini uses: .agent/workflows/<id>.md
                // User scope: ~/.gemini/antigravity/global_workflows/<id>.md
                let base = if is_user_scope {
                    PathBuf::from("~")
                        .join(".gemini")
                        .join("antigravity")
                        .join("global_workflows")
                } else {
                    PathBuf::from(".agent").join("workflows")
                };
                Some(base.join(format!("{}.md", asset_id)))
            }
            Target::Codex => {
                // Codex uses: ~/.codex/prompts/<id>.md or .codex/prompts/<id>.md
                let base = if is_user_scope {
                    PathBuf::from("~").join(".codex").join("prompts")
                } else {
                    PathBuf::from(".codex").join("prompts")
                };
                Some(base.join(format!("{}.md", asset_id)))
            }
            Target::All => None, // All is expanded before this
        }
    }

    /// Get the commands/action path for a target
    ///
    /// # Arguments
    /// * `target` - The target platform
    /// * `asset_id` - The asset identifier (used for filename)
    /// * `is_user_scope` - Whether this is a user-level (global) asset
    ///
    /// # Returns
    /// The path where the command file should be written, or None if the target
    /// doesn't support commands.
    pub fn commands_path(target: Target, asset_id: &str, is_user_scope: bool) -> Option<PathBuf> {
        match target {
            Target::ClaudeCode => {
                let base = if is_user_scope {
                    PathBuf::from("~").join(".claude").join("commands")
                } else {
                    PathBuf::from(".claude").join("commands")
                };
                Some(base.join(format!("{}.md", asset_id)))
            }
            Target::Cursor => {
                // Cursor reads Claude's commands, but can also have its own
                let base = if is_user_scope {
                    PathBuf::from("~").join(".cursor").join("commands")
                } else {
                    PathBuf::from(".cursor").join("commands")
                };
                Some(base.join(format!("{}.md", asset_id)))
            }
            _ => None, // Other targets don't have slash commands
        }
    }

    /// Get the prompts path for Codex
    pub fn codex_prompts_path(asset_id: &str, is_user_scope: bool) -> PathBuf {
        let base = if is_user_scope {
            PathBuf::from("~").join(".codex").join("prompts")
        } else {
            PathBuf::from(".codex").join("prompts")
        };
        base.join(format!("{}.md", asset_id))
    }

    /// Get the workflows path for Antigravity/Gemini
    pub fn antigravity_workflows_path(asset_id: &str, is_user_scope: bool) -> PathBuf {
        let base = if is_user_scope {
            PathBuf::from("~")
                .join(".gemini")
                .join("antigravity")
                .join("global_workflows")
        } else {
            PathBuf::from(".agent").join("workflows")
        };
        base.join(format!("{}.md", asset_id))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // === TDD: CompilationResult ===

    #[test]
    fn result_new_is_empty() {
        let result = CompilationResult::new();
        assert!(result.is_empty());
        assert_eq!(result.len(), 0);
        assert!(!result.has_warnings());
    }

    #[test]
    fn result_single() {
        let output = OutputFile::new("test.md", "content", Target::ClaudeCode);
        let result = CompilationResult::single(output);

        assert!(!result.is_empty());
        assert_eq!(result.len(), 1);
    }

    #[test]
    fn result_many() {
        let outputs = vec![
            OutputFile::new("a.md", "a", Target::ClaudeCode),
            OutputFile::new("b.md", "b", Target::Cursor),
        ];
        let result = CompilationResult::many(outputs);

        assert_eq!(result.len(), 2);
    }

    #[test]
    fn result_with_warning() {
        let result = CompilationResult::new()
            .with_warning("Warning 1")
            .with_warning("Warning 2");

        assert!(result.has_warnings());
        assert_eq!(result.warnings.len(), 2);
    }

    #[test]
    fn result_merge() {
        let r1 = CompilationResult::single(OutputFile::new("a.md", "a", Target::ClaudeCode))
            .with_warning("W1");
        let r2 = CompilationResult::single(OutputFile::new("b.md", "b", Target::Cursor))
            .with_warning("W2");

        let merged = r1.merge(r2);

        assert_eq!(merged.len(), 2);
        assert_eq!(merged.warnings.len(), 2);
    }

    // === TDD: Footer Generation ===

    #[test]
    fn generate_footer_html() {
        let footer = generate_footer("test.md", "0.2.0");
        assert!(footer.contains("Generated by Calvin"));
        // Version is no longer included in footer to avoid snapshot churn
        assert!(footer.contains("test.md"));
        assert!(footer.starts_with("<!--"));
    }

    #[test]
    fn generate_footer_comment() {
        let footer = generate_comment_footer("test.md", "0.2.0");
        assert!(footer.starts_with("# Generated by Calvin"));
        assert!(footer.contains("test.md"));
    }

    // === TDD: PathGenerator ===

    #[test]
    fn path_generator_claude_rules_project() {
        let path = PathGenerator::rules_path(Target::ClaudeCode, "test-rule", false);
        // Claude uses .join() for platform-agnostic paths
        let expected = PathBuf::from(".claude")
            .join("commands")
            .join("test-rule.md");
        assert_eq!(path, Some(expected));
    }

    #[test]
    fn path_generator_claude_rules_user() {
        let path = PathGenerator::rules_path(Target::ClaudeCode, "test-rule", true);
        let expected = PathBuf::from("~")
            .join(".claude")
            .join("commands")
            .join("test-rule.md");
        assert_eq!(path, Some(expected));
    }

    #[test]
    fn path_generator_cursor_rules_project() {
        let path = PathGenerator::rules_path(Target::Cursor, "test-rule", false);
        // Cursor uses: .cursor/rules/<id>/RULE.md
        let expected = PathBuf::from(".cursor")
            .join("rules")
            .join("test-rule")
            .join("RULE.md");
        assert_eq!(path, Some(expected));
    }

    #[test]
    fn path_generator_cursor_rules_user() {
        let path = PathGenerator::rules_path(Target::Cursor, "test-rule", true);
        let expected = PathBuf::from("~")
            .join(".cursor")
            .join("rules")
            .join("test-rule")
            .join("RULE.md");
        assert_eq!(path, Some(expected));
    }

    #[test]
    fn path_generator_vscode_project_only() {
        let path = PathGenerator::rules_path(Target::VSCode, "test-rule", false);
        let expected = PathBuf::from(".github")
            .join("instructions")
            .join("test-rule.instructions.md");
        assert_eq!(path, Some(expected));

        // User scope not supported for VSCode
        let path = PathGenerator::rules_path(Target::VSCode, "test-rule", true);
        assert_eq!(path, None);
    }

    #[test]
    fn path_generator_antigravity_both_scopes() {
        // Project scope
        let path = PathGenerator::rules_path(Target::Antigravity, "test-rule", false);
        let expected = PathBuf::from(".agent")
            .join("workflows")
            .join("test-rule.md");
        assert_eq!(path, Some(expected));

        // User scope - goes to ~/.gemini/antigravity/global_workflows/
        let path = PathGenerator::rules_path(Target::Antigravity, "test-rule", true);
        let expected = PathBuf::from("~")
            .join(".gemini")
            .join("antigravity")
            .join("global_workflows")
            .join("test-rule.md");
        assert_eq!(path, Some(expected));
    }

    #[test]
    fn path_generator_codex_both_scopes() {
        // Project scope
        let path = PathGenerator::rules_path(Target::Codex, "test-rule", false);
        let expected = PathBuf::from(".codex").join("prompts").join("test-rule.md");
        assert_eq!(path, Some(expected));

        // User scope
        let path = PathGenerator::rules_path(Target::Codex, "test-rule", true);
        let expected = PathBuf::from("~")
            .join(".codex")
            .join("prompts")
            .join("test-rule.md");
        assert_eq!(path, Some(expected));
    }

    #[test]
    fn path_generator_all_returns_none() {
        let path = PathGenerator::rules_path(Target::All, "test-rule", false);
        assert_eq!(path, None);
    }

    #[test]
    fn path_generator_claude_commands() {
        let path = PathGenerator::commands_path(Target::ClaudeCode, "my-cmd", false);
        let expected = PathBuf::from(".claude").join("commands").join("my-cmd.md");
        assert_eq!(path, Some(expected));

        let path = PathGenerator::commands_path(Target::ClaudeCode, "my-cmd", true);
        let expected = PathBuf::from("~")
            .join(".claude")
            .join("commands")
            .join("my-cmd.md");
        assert_eq!(path, Some(expected));
    }

    #[test]
    fn path_generator_cursor_commands() {
        let path = PathGenerator::commands_path(Target::Cursor, "my-cmd", false);
        let expected = PathBuf::from(".cursor").join("commands").join("my-cmd.md");
        assert_eq!(path, Some(expected));
    }

    #[test]
    fn path_generator_no_commands_for_other_targets() {
        assert_eq!(
            PathGenerator::commands_path(Target::VSCode, "cmd", false),
            None
        );
        assert_eq!(
            PathGenerator::commands_path(Target::Antigravity, "cmd", false),
            None
        );
        assert_eq!(
            PathGenerator::commands_path(Target::Codex, "cmd", false),
            None
        );
    }

    #[test]
    fn path_generator_codex_prompts() {
        let path = PathGenerator::codex_prompts_path("my-prompt", false);
        let expected = PathBuf::from(".codex").join("prompts").join("my-prompt.md");
        assert_eq!(path, expected);

        let path = PathGenerator::codex_prompts_path("my-prompt", true);
        let expected = PathBuf::from("~")
            .join(".codex")
            .join("prompts")
            .join("my-prompt.md");
        assert_eq!(path, expected);
    }

    #[test]
    fn path_generator_antigravity_workflows() {
        let path = PathGenerator::antigravity_workflows_path("my-workflow", false);
        let expected = PathBuf::from(".agent")
            .join("workflows")
            .join("my-workflow.md");
        assert_eq!(path, expected);

        let path = PathGenerator::antigravity_workflows_path("my-workflow", true);
        let expected = PathBuf::from("~")
            .join(".gemini")
            .join("antigravity")
            .join("global_workflows")
            .join("my-workflow.md");
        assert_eq!(path, expected);
    }
}
