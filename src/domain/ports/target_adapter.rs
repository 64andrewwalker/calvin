//! TargetAdapter port - interface for platform-specific compilation
//!
//! This port defines how domain entities (Assets) are transformed into
//! platform-specific output files (OutputFiles).

use crate::domain::entities::{Asset, OutputFile};
use crate::domain::value_objects::Target;
use std::fmt;

/// Error type for adapter operations
#[derive(Debug)]
pub enum AdapterError {
    /// Asset cannot be compiled for this target
    UnsupportedAssetKind { kind: String, target: Target },
    /// Compilation failed
    CompilationFailed { message: String },
    /// Validation failed
    ValidationFailed { diagnostics: Vec<AdapterDiagnostic> },
}

impl fmt::Display for AdapterError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AdapterError::UnsupportedAssetKind { kind, target } => {
                write!(
                    f,
                    "Asset kind '{}' is not supported by target '{}'",
                    kind,
                    target.display_name()
                )
            }
            AdapterError::CompilationFailed { message } => {
                write!(f, "Compilation failed: {}", message)
            }
            AdapterError::ValidationFailed { diagnostics } => {
                write!(
                    f,
                    "Validation failed: {}",
                    diagnostics
                        .iter()
                        .map(|d| d.message.as_str())
                        .collect::<Vec<_>>()
                        .join(", ")
                )
            }
        }
    }
}

impl std::error::Error for AdapterError {}

/// Diagnostic message from adapter validation
#[derive(Debug, Clone, PartialEq)]
pub struct AdapterDiagnostic {
    /// Severity of the diagnostic
    pub severity: DiagnosticSeverity,
    /// Message
    pub message: String,
}

/// Severity levels for diagnostics
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DiagnosticSeverity {
    Error,
    Warning,
    Info,
}

/// Port trait for platform-specific adapters
///
/// Each adapter transforms Assets into platform-specific OutputFiles.
/// Adapters are pure functions that don't perform I/O.
pub trait TargetAdapter: Send + Sync {
    /// Target identifier for this adapter
    fn target(&self) -> Target;

    /// Adapter version (for cache invalidation, etc.)
    fn version(&self) -> u8 {
        1
    }

    /// Compile a single asset into platform-specific output files
    ///
    /// Returns empty Vec if this asset type is not supported by the target.
    fn compile(&self, asset: &Asset) -> Result<Vec<OutputFile>, AdapterError>;

    /// Validate generated output against platform best practices
    fn validate(&self, output: &OutputFile) -> Vec<AdapterDiagnostic>;

    /// Perform post-compilation tasks
    ///
    /// Called after all individual assets have been compiled.
    /// Used for generating summary files, indexes, etc.
    fn post_compile(&self, assets: &[Asset]) -> Result<Vec<OutputFile>, AdapterError> {
        let _ = assets; // Mark as intentionally unused
        Ok(Vec::new())
    }

    /// Generate security baseline configuration
    ///
    /// Creates platform-specific security configuration files
    /// (deny lists, permissions, etc.)
    fn security_baseline(
        &self,
        config: &crate::config::Config,
    ) -> Result<Vec<OutputFile>, AdapterError> {
        let _ = config;
        Ok(Vec::new())
    }

    /// Generate header marker for generated files
    fn header(&self, source_path: &str) -> String {
        format!(
            "<!-- Generated by Calvin {} (Adapter v{}). Source: {}. DO NOT EDIT. -->\n\n",
            env!("CARGO_PKG_VERSION"),
            self.version(),
            source_path
        )
    }

    /// Generate footer marker for generated files
    fn footer(&self, source_path: &str) -> String {
        format!(
            "<!-- Generated by Calvin {} (Adapter v{}). Source: {}. DO NOT EDIT. -->",
            env!("CARGO_PKG_VERSION"),
            self.version(),
            source_path
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::entities::Asset;

    /// Mock adapter for testing
    struct MockAdapter {
        target: Target,
    }

    impl MockAdapter {
        fn new(target: Target) -> Self {
            Self { target }
        }
    }

    impl TargetAdapter for MockAdapter {
        fn target(&self) -> Target {
            self.target
        }

        fn compile(&self, asset: &Asset) -> Result<Vec<OutputFile>, AdapterError> {
            Ok(vec![OutputFile::new(
                format!(".test/{}.md", asset.id()),
                asset.content().to_string(),
                self.target,
            )])
        }

        fn validate(&self, output: &OutputFile) -> Vec<AdapterDiagnostic> {
            if output.is_empty() {
                vec![AdapterDiagnostic {
                    severity: DiagnosticSeverity::Warning,
                    message: "Empty output".to_string(),
                }]
            } else {
                vec![]
            }
        }
    }

    #[test]
    fn mock_adapter_returns_target() {
        let adapter = MockAdapter::new(Target::ClaudeCode);
        assert_eq!(adapter.target(), Target::ClaudeCode);
    }

    #[test]
    fn mock_adapter_compiles_asset() {
        let adapter = MockAdapter::new(Target::Cursor);
        let asset = Asset::new("test", "test.md", "Test asset", "# Content");

        let outputs = adapter.compile(&asset).unwrap();

        assert_eq!(outputs.len(), 1);
        assert_eq!(outputs[0].path().to_string_lossy(), ".test/test.md");
        assert_eq!(outputs[0].content(), "# Content");
    }

    #[test]
    fn mock_adapter_validates_output() {
        let adapter = MockAdapter::new(Target::Cursor);
        let empty_output = OutputFile::new("test.md", "", Target::Cursor);
        let valid_output = OutputFile::new("test.md", "content", Target::Cursor);

        let empty_diags = adapter.validate(&empty_output);
        let valid_diags = adapter.validate(&valid_output);

        assert_eq!(empty_diags.len(), 1);
        assert!(valid_diags.is_empty());
    }

    #[test]
    fn adapter_has_default_version() {
        let adapter = MockAdapter::new(Target::ClaudeCode);
        assert_eq!(adapter.version(), 1);
    }

    #[test]
    fn adapter_generates_header() {
        let adapter = MockAdapter::new(Target::ClaudeCode);
        let header = adapter.header("test.md");

        assert!(header.contains("Generated by Calvin"));
        assert!(header.contains("test.md"));
        assert!(header.contains("DO NOT EDIT"));
    }

    #[test]
    fn adapter_generates_footer() {
        let adapter = MockAdapter::new(Target::ClaudeCode);
        let footer = adapter.footer("test.md");

        assert!(footer.contains("Generated by Calvin"));
        assert!(footer.contains("test.md"));
        assert!(footer.contains("DO NOT EDIT"));
    }

    #[test]
    fn post_compile_default_returns_empty() {
        let adapter = MockAdapter::new(Target::ClaudeCode);
        let assets = vec![];

        let outputs = adapter.post_compile(&assets).unwrap();
        assert!(outputs.is_empty());
    }
}
