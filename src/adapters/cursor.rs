//! Cursor IDE adapter
//!
//! Generates output for Cursor:
//! - `.cursor/rules/<id>/RULE.md` - Rules with frontmatter
//! - `.cursor/commands/<id>.md` - Slash commands

use std::path::PathBuf;

use crate::adapters::{Diagnostic, OutputFile, TargetAdapter};
use crate::error::CalvinResult;
use crate::models::{AssetKind, PromptAsset, Target};

/// Cursor adapter
pub struct CursorAdapter;

impl CursorAdapter {
    pub fn new() -> Self {
        Self
    }

    /// Generate RULE.md frontmatter based on asset properties
    fn generate_rule_frontmatter(&self, asset: &PromptAsset) -> String {
        let mut fm = String::from("---\n");
        
        fm.push_str(&format!("description: {}\n", asset.frontmatter.description));
        
        // Add globs if apply pattern is specified
        if let Some(apply) = &asset.frontmatter.apply {
            fm.push_str(&format!("globs: \"{}\"\n", apply));
        }
        
        // Policies without apply pattern should be always applied
        if asset.frontmatter.kind == AssetKind::Policy && asset.frontmatter.apply.is_none() {
            fm.push_str("alwaysApply: true\n");
        }
        
        fm.push_str("---\n");
        fm
    }
}

impl Default for CursorAdapter {
    fn default() -> Self {
        Self::new()
    }
}

impl TargetAdapter for CursorAdapter {
    fn target(&self) -> Target {
        Target::Cursor
    }

    fn compile(&self, asset: &PromptAsset) -> CalvinResult<Vec<OutputFile>> {
        let mut outputs = Vec::new();

        match asset.frontmatter.kind {
            AssetKind::Policy => {
                // Generate rule file: .cursor/rules/<id>/RULE.md
                let rule_path = PathBuf::from(".cursor/rules")
                    .join(&asset.id)
                    .join("RULE.md");

                let header = self.header(&asset.source_path.display().to_string());
                let frontmatter = self.generate_rule_frontmatter(asset);
                let content = format!(
                    "{}{}\n{}",
                    header,
                    frontmatter,
                    asset.content.trim()
                );

                outputs.push(OutputFile::new(rule_path, content));
            }
            AssetKind::Action | AssetKind::Agent => {
                // Generate command file: .cursor/commands/<id>.md
                let command_path = PathBuf::from(".cursor/commands")
                    .join(format!("{}.md", asset.id));

                let header = self.header(&asset.source_path.display().to_string());
                let content = format!(
                    "{}{}\n\n{}",
                    header,
                    asset.frontmatter.description,
                    asset.content.trim()
                );

                outputs.push(OutputFile::new(command_path, content));
            }
        }

        Ok(outputs)
    }

    fn validate(&self, _output: &OutputFile) -> Vec<Diagnostic> {
        // TODO: Implement validation
        Vec::new()
    }

    fn security_baseline(&self, config: &crate::config::Config) -> Vec<OutputFile> {
        let mut outputs = Vec::new();
        
        // Generate mcp.json from allowlist in config
        // This enforces "whitelist only" policy
        if !config.mcp.servers.is_empty() {
             let mcp_json = serde_json::json!({
                 "mcpServers": config.mcp.servers
             });
             let content = serde_json::to_string_pretty(&mcp_json).unwrap_or_default();
             outputs.push(OutputFile::new(".cursor/mcp.json", content));
        }
        
        outputs
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::Frontmatter;

    #[test]
    fn test_cursor_adapter_compile_policy() {
        let adapter = CursorAdapter::new();
        let fm = Frontmatter::new("Code style rules");
        let asset = PromptAsset::new(
            "code-style",
            "policies/code-style.md",
            fm,
            "# Code Style\n\nFollow these rules.",
        );

        let outputs = adapter.compile(&asset).unwrap();
        
        assert_eq!(outputs.len(), 1);
        assert_eq!(
            outputs[0].path,
            PathBuf::from(".cursor/rules/code-style/RULE.md")
        );
        assert!(outputs[0].content.contains("Generated by Calvin"));
        assert!(outputs[0].content.contains("description: Code style rules"));
        assert!(outputs[0].content.contains("alwaysApply: true"));
    }

    #[test]
    fn test_cursor_adapter_compile_policy_with_apply() {
        let adapter = CursorAdapter::new();
        let mut fm = Frontmatter::new("Rust rules");
        fm.apply = Some("*.rs".to_string());
        let asset = PromptAsset::new(
            "rust-style",
            "policies/rust-style.md",
            fm,
            "# Rust Style",
        );

        let outputs = adapter.compile(&asset).unwrap();
        
        assert!(outputs[0].content.contains("globs: \"*.rs\""));
        assert!(!outputs[0].content.contains("alwaysApply"));
    }

    #[test]
    fn test_cursor_adapter_compile_action() {
        let adapter = CursorAdapter::new();
        let mut fm = Frontmatter::new("Generate tests");
        fm.kind = AssetKind::Action;
        let asset = PromptAsset::new(
            "gen-tests",
            "actions/gen-tests.md",
            fm,
            "# Generate Tests",
        );

        let outputs = adapter.compile(&asset).unwrap();
        
        assert_eq!(outputs.len(), 1);
        assert_eq!(
            outputs[0].path,
            PathBuf::from(".cursor/commands/gen-tests.md")
        );
    }

    #[test]
    fn test_cursor_rule_frontmatter() {
        let adapter = CursorAdapter::new();
        let fm = Frontmatter::new("Test policy");
        let asset = PromptAsset::new(
            "test",
            "policies/test.md",
            fm,
            "",
        );

        let frontmatter = adapter.generate_rule_frontmatter(&asset);
        
        assert!(frontmatter.starts_with("---\n"));
        assert!(frontmatter.ends_with("---\n"));
        assert!(frontmatter.contains("description: Test policy"));
    }

    #[test]
    fn test_cursor_security_baseline_empty() {
        let adapter = CursorAdapter::new();
        let config = crate::config::Config::default();
        let baseline = adapter.security_baseline(&config);
        assert!(baseline.is_empty());
    }

    #[test]
    fn test_cursor_security_baseline_mcp() {
        let adapter = CursorAdapter::new();
        let mut config = crate::config::Config::default();
        
        // Add a mock MCP server
        config.mcp.servers.insert(
            "test-server".to_string(), 
            crate::config::McpServerConfig {
                command: "node".to_string(),
                args: vec!["server.js".to_string()],
            }
        );
        
        let baseline = adapter.security_baseline(&config);
        
        assert_eq!(baseline.len(), 1);
        assert_eq!(baseline[0].path, PathBuf::from(".cursor/mcp.json"));
        assert!(baseline[0].content.contains("test-server"));
        assert!(baseline[0].content.contains("node"));
    }
}
