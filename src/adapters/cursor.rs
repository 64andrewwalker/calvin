//! Cursor IDE adapter
//!
//! Generates output for Cursor:
//! - `.cursor/rules/<id>/RULE.md` - Rules with frontmatter
//! - `.cursor/commands/<id>.md` - Slash commands

use std::path::PathBuf;

use crate::adapters::{Diagnostic, DiagnosticSeverity, OutputFile, TargetAdapter};
use crate::error::CalvinResult;
use crate::models::{AssetKind, PromptAsset, Scope, Target};

/// Cursor adapter
pub struct CursorAdapter;

impl CursorAdapter {
    pub fn new() -> Self {
        Self
    }

    /// Generate RULE.md frontmatter based on asset properties
    fn generate_rule_frontmatter(&self, asset: &PromptAsset) -> String {
        let mut fm = String::from("---\n");

        fm.push_str(&format!("description: {}\n", asset.frontmatter.description));

        // Add globs if apply pattern is specified
        if let Some(apply) = &asset.frontmatter.apply {
            fm.push_str(&format!("globs: \"{}\"\n", apply));
        }

        // alwaysApply: true only for policies without apply pattern
        // Actions/Agents should NOT be alwaysApply
        if asset.frontmatter.kind == AssetKind::Policy && asset.frontmatter.apply.is_none() {
            fm.push_str("alwaysApply: true\n");
        } else {
            fm.push_str("alwaysApply: false\n");
        }

        fm.push_str("---\n");
        fm
    }
}

impl Default for CursorAdapter {
    fn default() -> Self {
        Self::new()
    }
}

impl TargetAdapter for CursorAdapter {
    fn target(&self) -> Target {
        Target::Cursor
    }

    fn compile(&self, asset: &PromptAsset) -> CalvinResult<Vec<OutputFile>> {
        let mut outputs = Vec::new();

        // Determine base path based on scope
        // Note: Cursor reads Claude's commands, so we only generate rules
        let rules_base = match asset.frontmatter.scope {
            Scope::User => PathBuf::from("~/.cursor/rules"),
            Scope::Project => PathBuf::from(".cursor/rules"),
        };

        match asset.frontmatter.kind {
            AssetKind::Policy => {
                // Generate rule file: <base>/rules/<id>/RULE.md
                let rule_path = rules_base.join(&asset.id).join("RULE.md");

                let frontmatter = self.generate_rule_frontmatter(asset);
                let footer = self.footer(&asset.source_path.display().to_string());
                let content = format!("{}\n{}\n\n{}", frontmatter, asset.content.trim(), footer);

                outputs.push(OutputFile::new(rule_path, content));
            }
            AssetKind::Action | AssetKind::Agent => {
                // Note: Cursor automatically reads Claude's commands from ~/.claude/commands/
                // So we don't need to generate separate command files for Cursor.
                // Only generate rules for policies.
            }
        }

        Ok(outputs)
    }

    fn validate(&self, output: &OutputFile) -> Vec<Diagnostic> {
        let mut diagnostics = Vec::new();

        if output.content.trim().is_empty() {
            diagnostics.push(Diagnostic {
                severity: DiagnosticSeverity::Warning,
                message: "Generated output is empty".to_string(),
                file: Some(output.path.clone()),
            });
        }

        diagnostics
    }

    fn security_baseline(&self, config: &crate::config::Config) -> Vec<OutputFile> {
        let mut outputs = Vec::new();

        // Generate mcp.json from allowlist in config
        // This enforces "whitelist only" policy
        if !config.mcp.servers.is_empty() {
            let mcp_json = serde_json::json!({
                "mcpServers": config.mcp.servers
            });
            let content = serde_json::to_string_pretty(&mcp_json).unwrap_or_default();
            outputs.push(OutputFile::new(".cursor/mcp.json", content));
        }

        outputs
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::Frontmatter;

    #[test]
    fn test_cursor_adapter_compile_policy() {
        let adapter = CursorAdapter::new();
        let mut fm = Frontmatter::new("Code style rules");
        fm.kind = AssetKind::Policy; // Explicitly set to Policy
        let asset = PromptAsset::new(
            "code-style",
            "policies/code-style.md",
            fm,
            "# Code Style\n\nFollow these rules.",
        );

        let outputs = adapter.compile(&asset).unwrap();

        assert_eq!(outputs.len(), 1);
        assert_eq!(
            outputs[0].path,
            PathBuf::from(".cursor/rules/code-style/RULE.md")
        );
        // Frontmatter should be at the very beginning
        assert!(outputs[0].content.starts_with("---\n"));
        assert!(outputs[0].content.contains("description: Code style rules"));
        assert!(outputs[0].content.contains("alwaysApply: true"));
        // Footer should be at the end
        assert!(outputs[0].content.ends_with("DO NOT EDIT. -->"));
        assert!(outputs[0].content.contains("Generated by Calvin"));
    }

    #[test]
    fn test_cursor_adapter_compile_policy_with_apply() {
        let adapter = CursorAdapter::new();
        let mut fm = Frontmatter::new("Rust rules");
        fm.kind = AssetKind::Policy; // Explicitly set to Policy
        fm.apply = Some("*.rs".to_string());
        let asset = PromptAsset::new("rust-style", "policies/rust-style.md", fm, "# Rust Style");

        let outputs = adapter.compile(&asset).unwrap();

        assert!(outputs[0].content.contains("globs: \"*.rs\""));
        // Policies with apply pattern have alwaysApply: false
        assert!(outputs[0].content.contains("alwaysApply: false"));
    }

    #[test]
    fn test_cursor_adapter_compile_action() {
        // Actions are NOT generated for Cursor - Cursor reads Claude's commands
        let adapter = CursorAdapter::new();
        let mut fm = Frontmatter::new("Generate tests");
        fm.kind = AssetKind::Action;
        let asset = PromptAsset::new("gen-tests", "actions/gen-tests.md", fm, "# Generate Tests");

        let outputs = adapter.compile(&asset).unwrap();

        // No output for actions - Cursor reads Claude's commands
        assert_eq!(outputs.len(), 0);
    }

    #[test]
    fn test_cursor_rule_frontmatter() {
        let adapter = CursorAdapter::new();
        let mut fm = Frontmatter::new("Test policy");
        fm.kind = AssetKind::Policy; // Explicitly set to Policy
        let asset = PromptAsset::new("test", "policies/test.md", fm, "");

        let frontmatter = adapter.generate_rule_frontmatter(&asset);

        assert!(frontmatter.starts_with("---\n"));
        assert!(frontmatter.ends_with("---\n"));
        assert!(frontmatter.contains("description: Test policy"));
    }

    #[test]
    fn test_cursor_security_baseline_empty() {
        let adapter = CursorAdapter::new();
        let config = crate::config::Config::default();
        let baseline = adapter.security_baseline(&config);
        assert!(baseline.is_empty());
    }

    #[test]
    fn test_cursor_security_baseline_mcp() {
        let adapter = CursorAdapter::new();
        let mut config = crate::config::Config::default();

        // Add a mock MCP server
        config.mcp.servers.insert(
            "test-server".to_string(),
            crate::config::McpServerConfig {
                command: "node".to_string(),
                args: vec!["server.js".to_string()],
            },
        );

        let baseline = adapter.security_baseline(&config);

        assert_eq!(baseline.len(), 1);
        assert_eq!(baseline[0].path, PathBuf::from(".cursor/mcp.json"));
        assert!(baseline[0].content.contains("test-server"));
        assert!(baseline[0].content.contains("node"));
    }
}
