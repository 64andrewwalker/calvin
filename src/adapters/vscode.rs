//! VS Code (GitHub Copilot) adapter
//!
//! Generates output for VS Code with GitHub Copilot:
//! - `.github/instructions/<id>.instructions.md` - Instruction files (default)
//! - `.github/copilot-instructions.md` - Merged instructions (optional)
//! - `AGENTS.md` - Summary index

use std::path::PathBuf;

use crate::adapters::{Diagnostic, DiagnosticSeverity, OutputFile, TargetAdapter};
use crate::error::CalvinResult;
use crate::models::{AssetKind, PromptAsset, Scope, Target};

/// VS Code adapter
pub struct VSCodeAdapter {
    /// Whether to merge policies into single copilot-instructions.md
    /// Default is false - generate individual .instructions.md files
    pub merge_mode: bool,
}

impl VSCodeAdapter {
    pub fn new() -> Self {
        Self { merge_mode: false }
    }

    pub fn with_split_mode(split_mode: bool) -> Self {
        // For backwards compat: split_mode=true means NOT merging
        Self {
            merge_mode: !split_mode,
        }
    }

    pub fn with_merge_mode(merge_mode: bool) -> Self {
        Self { merge_mode }
    }

    /// Generate applyTo frontmatter for instruction files
    fn generate_instruction_frontmatter(&self, asset: &PromptAsset) -> String {
        let mut fm = String::from("---\n");

        fm.push_str(&format!("description: {}\n", asset.frontmatter.description));

        if let Some(apply) = &asset.frontmatter.apply {
            fm.push_str(&format!("applyTo: \"{}\"\n", apply));
        }

        fm.push_str("---\n");
        fm
    }
}

impl Default for VSCodeAdapter {
    fn default() -> Self {
        Self::new()
    }
}

impl TargetAdapter for VSCodeAdapter {
    fn target(&self) -> Target {
        Target::VSCode
    }

    fn compile(&self, asset: &PromptAsset) -> CalvinResult<Vec<OutputFile>> {
        let mut outputs = Vec::new();
        let footer = self.footer(&asset.source_path.display().to_string());

        // Determine base path based on scope
        // User scope: VS Code stores user instructions in profile, but we use ~/.vscode/
        let instructions_base = match asset.frontmatter.scope {
            Scope::User => PathBuf::from("~/.vscode/instructions"),
            Scope::Project => PathBuf::from(".github/instructions"),
        };

        // All assets generate individual .instructions.md files by default
        // Merge mode is optional and handled in post_compile()
        if !self.merge_mode
            || asset.frontmatter.apply.is_some()
            || asset.frontmatter.scope == Scope::User
        {
            let path = instructions_base.join(format!("{}.instructions.md", asset.id));

            let frontmatter = self.generate_instruction_frontmatter(asset);
            let content = format!("{}\n{}\n\n{}", frontmatter, asset.content.trim(), footer);

            outputs.push(OutputFile::new(path, content));
        }
        // If merge_mode is true and no applyTo, the policy will be merged in post_compile()

        Ok(outputs)
    }

    fn validate(&self, output: &OutputFile) -> Vec<Diagnostic> {
        let mut diagnostics = Vec::new();

        if output.content.trim().is_empty() {
            diagnostics.push(Diagnostic {
                severity: DiagnosticSeverity::Warning,
                message: "Generated output is empty".to_string(),
                file: Some(output.path.clone()),
            });
        }

        if output.content.contains("TODO") {
            diagnostics.push(Diagnostic {
                severity: DiagnosticSeverity::Info,
                message: "Output contains TODO markers".to_string(),
                file: Some(output.path.clone()),
            });
        }

        diagnostics
    }

    fn security_baseline(&self, _config: &crate::config::Config) -> Vec<OutputFile> {
        // VS Code doesn't have a central security config
        // Security is handled via settings.json in the IDE
        Vec::new()
    }

    fn post_compile(&self, assets: &[PromptAsset]) -> CalvinResult<Vec<OutputFile>> {
        let mut outputs = Vec::new();

        // Only generate merged copilot-instructions.md when merge_mode is enabled
        if self.merge_mode {
            let merged_policies: Vec<_> = assets
                .iter()
                .filter(|a| a.frontmatter.kind == AssetKind::Policy)
                .filter(|a| a.frontmatter.apply.is_none())
                .filter(|a| a.frontmatter.scope == Scope::Project)
                .collect();

            if !merged_policies.is_empty() {
                let mut content = String::from("<!-- Generated by Calvin. DO NOT EDIT. -->\n\n");
                content.push_str("# Copilot Instructions\n\n");

                for asset in &merged_policies {
                    content.push_str(&format!("## {}\n\n", asset.frontmatter.description));
                    content.push_str(asset.content.trim());
                    content.push_str("\n\n");
                }

                outputs.push(OutputFile::new(".github/copilot-instructions.md", content));
            }
        }

        // Generate AGENTS.md
        let agents_content = generate_agents_md(assets);
        outputs.push(OutputFile::new("AGENTS.md", agents_content));

        Ok(outputs)
    }
}

/// Generate AGENTS.md summary index from all assets
pub fn generate_agents_md(assets: &[PromptAsset]) -> String {
    let mut content = String::from("# AGENTS.md\n\n");
    content.push_str("<!-- Generated by Calvin. DO NOT EDIT. -->\n\n");
    content.push_str("This file provides an index of available AI agents and workflows.\n\n");

    // Group by kind
    let policies: Vec<_> = assets
        .iter()
        .filter(|a| a.frontmatter.kind == AssetKind::Policy)
        .collect();
    let actions: Vec<_> = assets
        .iter()
        .filter(|a| a.frontmatter.kind == AssetKind::Action)
        .collect();
    let agents: Vec<_> = assets
        .iter()
        .filter(|a| a.frontmatter.kind == AssetKind::Agent)
        .collect();

    if !policies.is_empty() {
        content.push_str("## Policies\n\n");
        for asset in policies {
            content.push_str(&format!(
                "- **{}**: {}\n",
                asset.id, asset.frontmatter.description
            ));
        }
        content.push('\n');
    }

    if !actions.is_empty() {
        content.push_str("## Actions\n\n");
        for asset in actions {
            content.push_str(&format!(
                "- **{}**: {}\n",
                asset.id, asset.frontmatter.description
            ));
        }
        content.push('\n');
    }

    if !agents.is_empty() {
        content.push_str("## Agents\n\n");
        for asset in agents {
            content.push_str(&format!(
                "- **{}**: {}\n",
                asset.id, asset.frontmatter.description
            ));
        }
        content.push('\n');
    }

    content
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::Frontmatter;

    #[test]
    fn test_vscode_adapter_compile_policy_default() {
        // Default mode: all assets generate individual .instructions.md files
        let adapter = VSCodeAdapter::new();
        let mut fm = Frontmatter::new("Code style rules");
        fm.kind = AssetKind::Policy; // Explicitly set to Policy
        let asset = PromptAsset::new(
            "code-style",
            "policies/code-style.md",
            fm,
            "# Code Style\n\nFollow these rules.",
        );

        let outputs = adapter.compile(&asset).unwrap();

        // Should generate individual instruction file
        assert_eq!(outputs.len(), 1);
        assert_eq!(
            outputs[0].path,
            PathBuf::from(".github/instructions/code-style.instructions.md")
        );
        // Frontmatter should be at the very beginning
        assert!(outputs[0].content.starts_with("---\n"));
        assert!(outputs[0].content.contains("description: Code style rules"));
        // Footer should be at the end
        assert!(outputs[0].content.ends_with("DO NOT EDIT. -->"));
    }

    #[test]
    fn test_vscode_adapter_merge_mode() {
        // Merge mode: policies without applyTo are merged in post_compile()
        let adapter = VSCodeAdapter::with_merge_mode(true);
        let mut fm = Frontmatter::new("Code style rules");
        fm.kind = AssetKind::Policy; // Explicitly set to Policy for merge mode
        let asset = PromptAsset::new(
            "code-style",
            "policies/code-style.md",
            fm,
            "# Code Style\n\nFollow these rules.",
        );

        // compile() returns nothing for mergeable policies
        let outputs = adapter.compile(&asset).unwrap();
        assert_eq!(outputs.len(), 0);

        // post_compile() generates merged file
        let post_outputs = adapter.post_compile(&[asset]).unwrap();

        let copilot_file = post_outputs
            .iter()
            .find(|o| o.path == std::path::Path::new(".github/copilot-instructions.md"));
        assert!(
            copilot_file.is_some(),
            "Should generate copilot-instructions.md"
        );
        assert!(copilot_file
            .unwrap()
            .content
            .contains("## Code style rules"));
    }

    #[test]
    fn test_vscode_adapter_compile_policy_with_apply() {
        let adapter = VSCodeAdapter::new();
        let mut fm = Frontmatter::new("Rust rules");
        fm.kind = AssetKind::Policy; // Explicitly set to Policy
        fm.apply = Some("**/*.rs".to_string());
        let asset = PromptAsset::new("rust-style", "policies/rust-style.md", fm, "# Rust Style");

        let outputs = adapter.compile(&asset).unwrap();

        assert_eq!(
            outputs[0].path,
            PathBuf::from(".github/instructions/rust-style.instructions.md")
        );
        assert!(outputs[0].content.contains("applyTo: \"**/*.rs\""));
    }

    #[test]
    fn test_vscode_adapter_split_mode() {
        let adapter = VSCodeAdapter::with_split_mode(true);
        let mut fm = Frontmatter::new("Generic rules");
        fm.kind = AssetKind::Policy; // Explicitly set to Policy
        let asset = PromptAsset::new("generic", "policies/generic.md", fm, "Content");

        let outputs = adapter.compile(&asset).unwrap();

        assert_eq!(
            outputs[0].path,
            PathBuf::from(".github/instructions/generic.instructions.md")
        );
    }

    #[test]
    fn test_vscode_adapter_compile_action() {
        let adapter = VSCodeAdapter::new();
        let mut fm = Frontmatter::new("Generate tests");
        fm.kind = AssetKind::Action;
        let asset = PromptAsset::new("gen-tests", "actions/gen-tests.md", fm, "# Generate Tests");

        let outputs = adapter.compile(&asset).unwrap();

        assert_eq!(
            outputs[0].path,
            PathBuf::from(".github/instructions/gen-tests.instructions.md")
        );
    }

    #[test]
    fn test_generate_agents_md() {
        let mut fm1 = Frontmatter::new("Security policy");
        fm1.kind = AssetKind::Policy; // Explicitly set to Policy
        let asset1 = PromptAsset::new("security", "policies/security.md", fm1, "");

        let fm2 = Frontmatter::new("Code review action");
        // fm2.kind defaults to Action now
        let asset2 = PromptAsset::new("code-review", "actions/code-review.md", fm2, "");

        let content = generate_agents_md(&[asset1, asset2]);

        assert!(content.contains("# AGENTS.md"));
        assert!(content.contains("## Policies"));
        assert!(content.contains("**security**: Security policy"));
        assert!(content.contains("## Actions"));
        assert!(content.contains("**code-review**: Code review action"));
    }

    #[test]
    fn test_vscode_security_baseline_empty() {
        let adapter = VSCodeAdapter::new();
        let config = crate::config::Config::default();
        let baseline = adapter.security_baseline(&config);
        assert!(baseline.is_empty());
    }
}
