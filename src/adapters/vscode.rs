//! VS Code (GitHub Copilot) adapter
//!
//! Generates output for VS Code with GitHub Copilot:
//! - `.github/copilot-instructions.md` - Merged instructions
//! - `.github/instructions/<id>.instructions.md` - Split instructions with applyTo
//! - `AGENTS.md` - Summary index

use std::path::PathBuf;

use crate::adapters::{Diagnostic, OutputFile, TargetAdapter};
use crate::error::CalvinResult;
use crate::models::{AssetKind, PromptAsset, Target};

/// VS Code adapter
pub struct VSCodeAdapter {
    /// Whether to use merged mode (single copilot-instructions.md)
    /// or split mode (multiple .instructions.md files)
    pub split_mode: bool,
}

impl VSCodeAdapter {
    pub fn new() -> Self {
        Self { split_mode: false }
    }

    pub fn with_split_mode(split_mode: bool) -> Self {
        Self { split_mode }
    }

    /// Generate applyTo frontmatter for instruction files
    fn generate_instruction_frontmatter(&self, asset: &PromptAsset) -> String {
        let mut fm = String::from("---\n");
        
        if let Some(apply) = &asset.frontmatter.apply {
            fm.push_str(&format!("applyTo: \"{}\"\n", apply));
        }
        
        fm.push_str("---\n");
        fm
    }
}

impl Default for VSCodeAdapter {
    fn default() -> Self {
        Self::new()
    }
}

impl TargetAdapter for VSCodeAdapter {
    fn target(&self) -> Target {
        Target::VSCode
    }

    fn compile(&self, asset: &PromptAsset) -> CalvinResult<Vec<OutputFile>> {
        let mut outputs = Vec::new();
        let header = self.header(&asset.source_path.display().to_string());

        match asset.frontmatter.kind {
            AssetKind::Policy => {
                if self.split_mode || asset.frontmatter.apply.is_some() {
                    // Split mode: .github/instructions/<id>.instructions.md
                    let path = PathBuf::from(".github/instructions")
                        .join(format!("{}.instructions.md", asset.id));

                    let frontmatter = self.generate_instruction_frontmatter(asset);
                    let content = format!(
                        "{}{}\n{}",
                        header,
                        frontmatter,
                        asset.content.trim()
                    );

                    outputs.push(OutputFile::new(path, content));
                } else {
                    // Merged mode: will be combined into copilot-instructions.md
                    // This is handled at a higher level during sync
                    // For now, generate a section for the merged file
                    let path = PathBuf::from(".github/copilot-instructions.md");
                    let content = format!(
                        "{}\n## {}\n\n{}",
                        header,
                        asset.frontmatter.description,
                        asset.content.trim()
                    );
                    outputs.push(OutputFile::new(path, content));
                }
            }
            AssetKind::Action | AssetKind::Agent => {
                // Actions become instruction files in VS Code
                let path = PathBuf::from(".github/instructions")
                    .join(format!("{}.instructions.md", asset.id));

                let content = format!(
                    "{}\n# {}\n\n{}",
                    header,
                    asset.frontmatter.description,
                    asset.content.trim()
                );

                outputs.push(OutputFile::new(path, content));
            }
        }

        Ok(outputs)
    }

    fn validate(&self, _output: &OutputFile) -> Vec<Diagnostic> {
        // TODO: Validate overlapping applyTo patterns
        Vec::new()
    }

    fn security_baseline(&self) -> Vec<OutputFile> {
        // VS Code doesn't have a central security config
        // Security is handled via settings.json in the IDE
        Vec::new()
    }
}

/// Generate AGENTS.md summary index from all assets
pub fn generate_agents_md(assets: &[PromptAsset]) -> String {
    let mut content = String::from("# AGENTS.md\n\n");
    content.push_str("<!-- Generated by Calvin. DO NOT EDIT. -->\n\n");
    content.push_str("This file provides an index of available AI agents and workflows.\n\n");
    
    // Group by kind
    let policies: Vec<_> = assets.iter()
        .filter(|a| a.frontmatter.kind == AssetKind::Policy)
        .collect();
    let actions: Vec<_> = assets.iter()
        .filter(|a| a.frontmatter.kind == AssetKind::Action)
        .collect();
    let agents: Vec<_> = assets.iter()
        .filter(|a| a.frontmatter.kind == AssetKind::Agent)
        .collect();

    if !policies.is_empty() {
        content.push_str("## Policies\n\n");
        for asset in policies {
            content.push_str(&format!("- **{}**: {}\n", asset.id, asset.frontmatter.description));
        }
        content.push('\n');
    }

    if !actions.is_empty() {
        content.push_str("## Actions\n\n");
        for asset in actions {
            content.push_str(&format!("- **{}**: {}\n", asset.id, asset.frontmatter.description));
        }
        content.push('\n');
    }

    if !agents.is_empty() {
        content.push_str("## Agents\n\n");
        for asset in agents {
            content.push_str(&format!("- **{}**: {}\n", asset.id, asset.frontmatter.description));
        }
        content.push('\n');
    }

    content
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::Frontmatter;

    #[test]
    fn test_vscode_adapter_compile_policy_merged() {
        let adapter = VSCodeAdapter::new();
        let fm = Frontmatter::new("Code style rules");
        let asset = PromptAsset::new(
            "code-style",
            "policies/code-style.md",
            fm,
            "# Code Style\n\nFollow these rules.",
        );

        let outputs = adapter.compile(&asset).unwrap();
        
        assert_eq!(outputs.len(), 1);
        assert_eq!(
            outputs[0].path,
            PathBuf::from(".github/copilot-instructions.md")
        );
        assert!(outputs[0].content.contains("## Code style rules"));
    }

    #[test]
    fn test_vscode_adapter_compile_policy_with_apply() {
        let adapter = VSCodeAdapter::new();
        let mut fm = Frontmatter::new("Rust rules");
        fm.apply = Some("**/*.rs".to_string());
        let asset = PromptAsset::new(
            "rust-style",
            "policies/rust-style.md",
            fm,
            "# Rust Style",
        );

        let outputs = adapter.compile(&asset).unwrap();
        
        assert_eq!(
            outputs[0].path,
            PathBuf::from(".github/instructions/rust-style.instructions.md")
        );
        assert!(outputs[0].content.contains("applyTo: \"**/*.rs\""));
    }

    #[test]
    fn test_vscode_adapter_split_mode() {
        let adapter = VSCodeAdapter::with_split_mode(true);
        let fm = Frontmatter::new("Generic rules");
        let asset = PromptAsset::new(
            "generic",
            "policies/generic.md",
            fm,
            "Content",
        );

        let outputs = adapter.compile(&asset).unwrap();
        
        assert_eq!(
            outputs[0].path,
            PathBuf::from(".github/instructions/generic.instructions.md")
        );
    }

    #[test]
    fn test_vscode_adapter_compile_action() {
        let adapter = VSCodeAdapter::new();
        let mut fm = Frontmatter::new("Generate tests");
        fm.kind = AssetKind::Action;
        let asset = PromptAsset::new(
            "gen-tests",
            "actions/gen-tests.md",
            fm,
            "# Generate Tests",
        );

        let outputs = adapter.compile(&asset).unwrap();
        
        assert_eq!(
            outputs[0].path,
            PathBuf::from(".github/instructions/gen-tests.instructions.md")
        );
    }

    #[test]
    fn test_generate_agents_md() {
        let fm1 = Frontmatter::new("Security policy");
        let asset1 = PromptAsset::new("security", "policies/security.md", fm1, "");

        let mut fm2 = Frontmatter::new("Code review action");
        fm2.kind = AssetKind::Action;
        let asset2 = PromptAsset::new("code-review", "actions/code-review.md", fm2, "");

        let content = generate_agents_md(&[asset1, asset2]);
        
        assert!(content.contains("# AGENTS.md"));
        assert!(content.contains("## Policies"));
        assert!(content.contains("**security**: Security policy"));
        assert!(content.contains("## Actions"));
        assert!(content.contains("**code-review**: Code review action"));
    }

    #[test]
    fn test_vscode_security_baseline_empty() {
        let adapter = VSCodeAdapter::new();
        let baseline = adapter.security_baseline();
        assert!(baseline.is_empty());
    }
}
