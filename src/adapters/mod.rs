//! Target platform adapters (LEGACY)
//!
//! **DEPRECATED**: This module is being replaced by `infrastructure::adapters`.
//!
//! New code should use:
//! - `crate::infrastructure::adapters::ClaudeCodeAdapter`
//! - `crate::infrastructure::adapters::CursorAdapter`
//! - `crate::infrastructure::adapters::VSCodeAdapter`
//! - `crate::infrastructure::adapters::AntigravityAdapter`
//! - `crate::infrastructure::adapters::CodexAdapter`
//!
//! This module remains for backward compatibility with existing sync engine.
//! It will be removed in v0.4.0.

pub mod antigravity;
pub mod claude_code;
pub mod codex;
pub mod cursor;
pub mod escaping;
pub mod vscode;

use std::path::PathBuf;

use crate::config::Config;
use crate::error::CalvinResult;
use crate::models::{PromptAsset, Target};

/// Output file to be written by the sync engine
#[derive(Debug, Clone, PartialEq)]
pub struct OutputFile {
    /// Target path relative to project root
    pub path: PathBuf,
    /// File content
    pub content: String,
    /// Whether this file requires atomic write
    pub atomic: bool,
}

impl OutputFile {
    /// Create a new output file
    pub fn new(path: impl Into<PathBuf>, content: impl Into<String>) -> Self {
        Self {
            path: path.into(),
            content: content.into(),
            atomic: true,
        }
    }

    /// Get path (for compatibility with domain::entities::OutputFile API)
    pub fn path(&self) -> &PathBuf {
        &self.path
    }

    /// Get content (for compatibility with domain::entities::OutputFile API)
    pub fn content(&self) -> &str {
        &self.content
    }
}

/// Diagnostic message from adapter validation
#[derive(Debug, Clone, PartialEq)]
pub struct Diagnostic {
    /// Severity of the diagnostic
    pub severity: DiagnosticSeverity,
    /// Message
    pub message: String,
    /// Related file path (if any)
    pub file: Option<PathBuf>,
}

/// Severity levels for diagnostics
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DiagnosticSeverity {
    Error,
    Warning,
    Info,
}

/// Trait for platform-specific adapters
///
/// Each adapter transforms PromptAssets into platform-specific files.
pub trait TargetAdapter {
    /// Target identifier
    fn target(&self) -> Target;

    /// Adapter specific version (for TD-18)
    fn version(&self) -> u8 {
        1
    }

    /// Compile a prompt asset into platform-specific output files
    fn compile(&self, asset: &PromptAsset) -> CalvinResult<Vec<OutputFile>>;

    /// Validate generated output against platform best practices
    fn validate(&self, output: &OutputFile) -> Vec<Diagnostic>;

    /// Generate security baseline configuration (deny lists, etc.)
    fn security_baseline(&self, _config: &Config) -> Vec<OutputFile>;

    /// Generate header marker for generated files
    fn header(&self, source_path: &str) -> String {
        format!(
            "<!-- Generated by Calvin {} (Adapter v{}). Source: {}. DO NOT EDIT. -->\n\n",
            env!("CARGO_PKG_VERSION"),
            self.version(),
            source_path
        )
    }

    /// Generate footer marker for generated files (placed at end of file)
    fn footer(&self, source_path: &str) -> String {
        format!(
            "<!-- Generated by Calvin {} (Adapter v{}). Source: {}. DO NOT EDIT. -->",
            env!("CARGO_PKG_VERSION"),
            self.version(),
            source_path
        )
    }

    /// Perform post-compilation tasks (e.g. generating summary files like AGENTS.md)
    /// This is called after all individual assets have been compiled.
    fn post_compile(&self, _assets: &[PromptAsset]) -> CalvinResult<Vec<OutputFile>> {
        Ok(Vec::new())
    }
}

/// Get all available adapters
pub fn all_adapters() -> Vec<Box<dyn TargetAdapter>> {
    vec![
        Box::new(claude_code::ClaudeCodeAdapter::new()),
        Box::new(cursor::CursorAdapter::new()),
        Box::new(vscode::VSCodeAdapter::new()),
        Box::new(antigravity::AntigravityAdapter::new()),
        Box::new(codex::CodexAdapter::new()),
    ]
}

/// Get adapter for a specific target
pub fn get_adapter(target: Target) -> Option<Box<dyn TargetAdapter>> {
    match target {
        Target::ClaudeCode => Some(Box::new(claude_code::ClaudeCodeAdapter::new())),
        Target::Cursor => Some(Box::new(cursor::CursorAdapter::new())),
        Target::VSCode => Some(Box::new(vscode::VSCodeAdapter::new())),
        Target::Antigravity => Some(Box::new(antigravity::AntigravityAdapter::new())),
        Target::Codex => Some(Box::new(codex::CodexAdapter::new())),
        Target::All => None, // Use all_adapters() instead
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_output_file_creation() {
        let file = OutputFile::new(".claude/commands/test.md", "# Test");
        assert_eq!(file.path, PathBuf::from(".claude/commands/test.md"));
        assert_eq!(file.content, "# Test");
        assert!(file.atomic);
    }

    #[test]
    fn test_all_adapters_returns_five() {
        let adapters = all_adapters();
        assert_eq!(adapters.len(), 5);
    }

    #[test]
    fn test_get_adapter_by_target() {
        assert!(get_adapter(Target::ClaudeCode).is_some());
        assert!(get_adapter(Target::Cursor).is_some());
        assert!(get_adapter(Target::VSCode).is_some());
        assert!(get_adapter(Target::Antigravity).is_some());
        assert!(get_adapter(Target::Codex).is_some());
        assert!(get_adapter(Target::All).is_none());
    }
}
