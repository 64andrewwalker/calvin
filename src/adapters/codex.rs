//! OpenAI Codex CLI adapter
//!
//! Generates output for Codex CLI prompts:
//! - `~/.codex/prompts/<id>.md` - User-level prompts with $ARGUMENTS

use std::path::PathBuf;

use crate::adapters::{Diagnostic, OutputFile, TargetAdapter};
use crate::error::CalvinResult;
use crate::models::{PromptAsset, Scope, Target};

/// Codex adapter
pub struct CodexAdapter;

impl CodexAdapter {
    pub fn new() -> Self {
        Self
    }

    /// Generate usage documentation header for prompts
    fn generate_usage_header(&self, asset: &PromptAsset) -> String {
        let mut header = String::new();
        
        header.push_str(&format!("# {}\n\n", asset.frontmatter.description));
        header.push_str(&format!(
            "<!-- Generated by Calvin. Source: {}. DO NOT EDIT. -->\n\n",
            asset.source_path.display()
        ));
        
        // Add usage documentation
        header.push_str("## Usage\n\n");
        header.push_str(&format!(
            "```\n/prompts:{} <arguments>\n```\n\n",
            asset.id
        ));
        header.push_str("Arguments are available via `$ARGUMENTS` in the prompt below.\n\n");
        header.push_str("---\n\n");
        
        header
    }

    /// Insert $ARGUMENTS placeholder if not already present
    fn ensure_arguments_placeholder(&self, content: &str) -> String {
        if content.contains("$ARGUMENTS") 
            || content.contains("$1")
            || content.contains("$KEY") 
        {
            // Already has placeholders
            content.to_string()
        } else {
            // Add a note about using $ARGUMENTS
            format!(
                "{}\n\n---\n\n**Note**: Use `$ARGUMENTS` to access user-provided arguments.",
                content
            )
        }
    }
}

impl Default for CodexAdapter {
    fn default() -> Self {
        Self::new()
    }
}

impl TargetAdapter for CodexAdapter {
    fn target(&self) -> Target {
        Target::Codex
    }

    fn compile(&self, asset: &PromptAsset) -> CalvinResult<Vec<OutputFile>> {
        let mut outputs = Vec::new();

        // Codex prompts are typically user-level
        // Project-level would need a different approach
        let base_path = if asset.frontmatter.scope == Scope::User {
            // This will be resolved to ~/.codex/prompts/ during sync
            PathBuf::from("~/.codex/prompts")
        } else {
            // For project scope, use a local prompts directory
            PathBuf::from(".codex/prompts")
        };

        let path = base_path.join(format!("{}.md", asset.id));
        let header = self.generate_usage_header(asset);
        let content_with_args = self.ensure_arguments_placeholder(&asset.content);
        let full_content = format!("{}{}", header, content_with_args);

        outputs.push(OutputFile::new(path, full_content));

        Ok(outputs)
    }

    fn validate(&self, output: &OutputFile) -> Vec<Diagnostic> {
        let mut diagnostics = Vec::new();

        // Check for named placeholders without documentation
        let content = &output.content;
        
        // Find $KEY patterns (named arguments)
        let mut i = 0;
        let chars: Vec<char> = content.chars().collect();
        while i < chars.len() {
            if chars[i] == '$' && i + 1 < chars.len() {
                let start = i + 1;
                let mut end = start;
                while end < chars.len() && (chars[end].is_alphanumeric() || chars[end] == '_') {
                    end += 1;
                }
                if end > start {
                    let key: String = chars[start..end].iter().collect();
                    // Skip common placeholders
                    if !["ARGUMENTS", "1", "2", "3", "4", "5", "6", "7", "8", "9"].contains(&key.as_str()) {
                        // This is a named placeholder - should be documented
                        if !content.contains(&format!("`{}`", key)) {
                            diagnostics.push(Diagnostic {
                                severity: crate::adapters::DiagnosticSeverity::Warning,
                                message: format!(
                                    "Named placeholder ${} should be documented in usage section",
                                    key
                                ),
                                file: Some(output.path.clone()),
                            });
                        }
                    }
                }
                i = end;
            } else {
                i += 1;
            }
        }

        diagnostics
    }

    fn security_baseline(&self) -> Vec<OutputFile> {
        // Codex doesn't have project-level security config
        Vec::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::Frontmatter;

    #[test]
    fn test_codex_adapter_compile_user_scope() {
        let adapter = CodexAdapter::new();
        let mut fm = Frontmatter::new("Generate unit tests");
        fm.scope = Scope::User;
        let asset = PromptAsset::new(
            "gen-tests",
            "actions/gen-tests.md",
            fm,
            "Generate unit tests for the given code.\n\n$ARGUMENTS",
        );

        let outputs = adapter.compile(&asset).unwrap();
        
        assert_eq!(outputs.len(), 1);
        assert_eq!(
            outputs[0].path,
            PathBuf::from("~/.codex/prompts/gen-tests.md")
        );
        assert!(outputs[0].content.contains("Generate unit tests"));
        assert!(outputs[0].content.contains("/prompts:gen-tests"));
    }

    #[test]
    fn test_codex_adapter_compile_project_scope() {
        let adapter = CodexAdapter::new();
        let mut fm = Frontmatter::new("Project-specific prompt");
        fm.scope = Scope::Project;
        let asset = PromptAsset::new(
            "project-prompt",
            "actions/project-prompt.md",
            fm,
            "Project content",
        );

        let outputs = adapter.compile(&asset).unwrap();
        
        assert_eq!(
            outputs[0].path,
            PathBuf::from(".codex/prompts/project-prompt.md")
        );
    }

    #[test]
    fn test_codex_usage_header() {
        let adapter = CodexAdapter::new();
        let fm = Frontmatter::new("Test prompt");
        let asset = PromptAsset::new("test", "actions/test.md", fm, "");

        let header = adapter.generate_usage_header(&asset);
        
        assert!(header.contains("# Test prompt"));
        assert!(header.contains("/prompts:test"));
        assert!(header.contains("$ARGUMENTS"));
    }

    #[test]
    fn test_codex_ensure_arguments_placeholder() {
        let adapter = CodexAdapter::new();
        
        // Content already has placeholder
        let content = "Process $ARGUMENTS here";
        assert_eq!(adapter.ensure_arguments_placeholder(content), content);
        
        // Content without placeholder
        let content = "Process the input";
        let result = adapter.ensure_arguments_placeholder(content);
        assert!(result.contains("$ARGUMENTS"));
    }

    #[test]
    fn test_codex_validate_undocumented_placeholder() {
        let adapter = CodexAdapter::new();
        let output = OutputFile::new(
            "test.md",
            "Use $PROJECT_NAME for the project",
        );

        let diagnostics = adapter.validate(&output);
        
        assert!(!diagnostics.is_empty());
        assert!(diagnostics[0].message.contains("PROJECT_NAME"));
    }

    #[test]
    fn test_codex_validate_documented_placeholder() {
        let adapter = CodexAdapter::new();
        let output = OutputFile::new(
            "test.md",
            "Use $PROJECT_NAME for the project.\n\n`PROJECT_NAME` - The name of the project",
        );

        let diagnostics = adapter.validate(&output);
        
        assert!(diagnostics.is_empty());
    }

    #[test]
    fn test_codex_security_baseline_empty() {
        let adapter = CodexAdapter::new();
        let baseline = adapter.security_baseline();
        assert!(baseline.is_empty());
    }
}
