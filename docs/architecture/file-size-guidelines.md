# 文件大小健康指南

> **Created**: 2025-12-19  
> **Status**: 实践指南

---

## 📏 大小阈值

| 阈值 | 行数 (实现代码) | 状态 | 行动 |
|------|-----------------|------|------|
| **舒适区** | < 200 lines | ✅ 正常 | 无需行动 |
| **灰色地带** | 200-400 lines | 🟡 观察 | 检查是否有多个关注点 |
| **警报区** | > 500 lines | 🔴 需要重构 | 必须拆分 |

**注意**：测试代码和文档注释会被"宽容对待"。一个 250 行实现 + 150 行测试的文件，心理负担远小于 400 行纯实现。

---

## 🤔 判断问题

与其数行数，不如问自己这些直觉问题：

1. **第一次打开这个文件时，我能不能在一分钟内说清楚它的职责？**
   - 如果不能，可能职责过多

2. **我要改一个函数的时候，会不会不自觉地开始全文件搜索"相关代码在哪"？**
   - 如果是，说明模块边界不清晰

3. **如果我把其中一段逻辑抽到新文件，名字是不是立刻就能自然地叫出来？**
   - 如果能，说明这段逻辑已经足够独立

一旦这些问题开始频繁出现，哪怕只有三百行，拆分往往也是对的。

---

## 🔧 工具支持

### 运行文件大小检查

```bash
./scripts/check-file-size.sh
```

输出示例：

```
📏 File Size Health Check
================================================

🔴 ALARM: src/security.rs
   Total: 1155 lines (impl: ~797)
   → Consider breaking into smaller modules

🟡 WATCH: src/sync/engine.rs
   Total: 1601 lines (impl: ~446)
   → Ask: Does this file have a single clear responsibility?

================================================
1 file(s) need refactoring (>500 impl lines)
```

### Pre-commit 集成

文件大小检查已集成到 `.githooks/pre-commit`：
- 每次提交时自动检查
- 只是警告，不会阻止提交
- 提醒开发者考虑重构

---

## 📚 当触发警报时该怎么办

1. **阅读架构文档**
   - `docs/architecture/layers.md` - 分层架构
   - `docs/architecture/directory.md` - 目录结构
   - `docs/architecture/review-senior.md` - 模块拆分建议

2. **识别可拆分的关注点**
   - 找出独立的逻辑单元
   - 给它们起一个自然的名字

3. **创建新模块**
   - 遵循现有目录结构
   - 保持向后兼容

4. **添加测试**
   - 确保行为一致
   - 覆盖边界条件

---

## 📊 当前状态 (2025-12-19)

### 🔴 需要重构

| 文件 | 实现行数 | 拆分建议 |
|------|----------|----------|
| `src/security.rs` | ~797 | 拆分为 policies/, doctor/, baseline/ |
| `src/commands/interactive.rs` | ~557 | 拆分为 menu/, handlers/ |
| `src/commands/deploy/cmd.rs` | ~542 | 提取逻辑到 runner.rs |
| `src/config.rs` | ~530 | 拆分为 loader/, validator/, defaults/ |

### 🟡 需要关注

| 文件 | 实现行数 | 备注 |
|------|----------|------|
| `src/sync/engine.rs` | ~446 | 测试多，实现实际较小 |
| `src/commands/deploy/runner.rs` | ~412 | 可接受，但关注 |
| `src/commands/check.rs` | ~424 | 可接受 |

---

## 💡 为什么这很重要

> 当文件逐渐逼近三百到四百行时，读者开始出现明显的**导航成本**：你需要频繁滚动、搜索函数名、来回在实现和测试之间跳转。

> 超过五百行，基本就会让大多数 Rust 工程师本能地感到不安了。这种不安并不是形式主义，而是经验告诉大家：**当一个文件长到这个程度，模块边界往往已经在代码里"自然浮现"，只是还没被显式地切出来。**

保持文件小巧的好处：
- 更容易理解和维护
- 减少合并冲突
- 更好的代码复用
- 更清晰的模块边界

