# PRD: Claude Code Subagent Compatibility

> Product Requirements Document for implementing Claude Code Subagent format support in Calvin

**Status**: Draft v2 (Revised after expert review)  
**Author**: AI Assistant  
**Date**: 2026-01-06  
**Related PR**: https://github.com/64andrewwalker/calvin/pull/30

---

## 1. Problem Statement

### Current State

Calvin currently compiles agents (`kind: agent`) to `.claude/agents/<id>.md` with a simple format:

```markdown
Description text

Content...

<!-- Generated by Calvin. Source: agents/foo.md. DO NOT EDIT. -->
```

### The Problem

This output format is **incompatible with Claude Code's Subagent specification**. Claude Code expects:

```markdown
---
name: code-reviewer
description: Review code changes proactively after edits
tools: Read, Grep, Glob
model: sonnet
permissionMode: default
skills: pr-review, security-check
---

System prompt content here.
```

Without proper YAML frontmatter, Claude Code:
- Cannot parse the agent's `name` or `description` for auto-delegation routing
- Cannot apply tool restrictions or model overrides
- Cannot pre-load skills into the subagent's context
- Will not recognize the file as a valid subagent definition

### Impact

Users who define agents in `.promptpack/agents/` expect them to work in Claude Code, but the current implementation produces unusable output.

---

## 2. Goals

### Primary Goals

1. **Format Compliance**: Generate Claude Code-compatible subagent files with proper YAML frontmatter
2. **Field Mapping**: Support all Claude Code subagent frontmatter fields
3. **Pattern Consistency**: Follow existing skill implementation patterns exactly
4. **Backward Compatibility**: Existing Calvin source files should continue to work

### Non-Goals (Out of Scope)

1. OpenCode agent compatibility (different format, separate PRD)
2. Runtime validation of tool names against Claude Code's tool inventory
3. Auto-generation of agents from templates

---

## 3. Claude Code Subagent Specification

### 3.1 File Structure

```
.claude/agents/<name>.md     # Project-level (priority)
~/.claude/agents/<name>.md   # User-level
```

### 3.2 Required Fields

| Field | Type | Description |
|-------|------|-------------|
| `name` | string | Unique identifier for the subagent (kebab-case) |
| `description` | string | **Critical**: Used for routing/auto-delegation. Should describe WHEN to use this agent. |

### 3.3 Optional Fields

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `tools` | string (comma-separated) | Inherit from main thread | Whitelist of allowed tools (e.g., `Read, Grep, Glob, Bash`) |
| `model` | string | `inherit` | Model to use: `sonnet`, `opus`, `haiku`, or `inherit` |
| `permissionMode` | string | `default` | Permission handling: `default`, `acceptEdits`, `dontAsk`, `bypassPermissions`, `plan`, `ignore` |
| `skills` | string (comma-separated) | None | Skills to pre-load at startup (e.g., `pr-review, security-check`) |

> **IMPORTANT**: Subagents do NOT inherit skills from the main thread. Users MUST explicitly list required skills in the `skills:` field, or those skills will not be available to the subagent.

### 3.4 Body Content

Everything after the YAML frontmatter closing `---` is the **system prompt** for the subagent.

### 3.5 Example Output

```markdown
---
name: code-reviewer
description: "Review code changes proactively after edits; focus on security, performance, maintainability. MUST BE USED after any significant code changes."
tools: Read, Grep, Glob, Bash
model: sonnet
permissionMode: default
skills: engineering-standards
---

You are a senior code reviewer. Your output must be actionable improvement suggestions.

Focus on:
- Security vulnerabilities
- Performance bottlenecks
- Maintainability concerns
- Test coverage gaps

Do NOT modify files directly. Provide patch suggestions only when explicitly requested.

<!-- Generated by Calvin. Source: agents/code-reviewer.md. DO NOT EDIT. -->
```

---

## 4. Calvin Source Format (Input)

### 4.1 Design Principle: Match Claude Code Exactly

**Calvin source format for agents now matches Claude Code output format exactly.** This eliminates cognitive overhead and allows users to copy-paste between `.promptpack/agents/` and `.claude/agents/`.

Key decisions:
1. **Directory inference**: Files in `agents/` directory are automatically `kind: agent` (no explicit `kind:` required)
2. **Field names match output**: Use `name`, `tools`, `skills`, `permissionMode` (not `agent-tools`, `agent-skills`, `permission-mode`)
3. **Comma-separated strings**: Match Claude Code format for `tools` and `skills`

### 4.2 Agent Frontmatter Fields

```yaml
---
name: code-reviewer                  # Optional: defaults to filename (kebab-case)
description: Review code changes     # REQUIRED
tools: Read, Grep, Glob, Bash        # Optional: comma-separated tool whitelist
model: sonnet                        # Optional: sonnet | opus | haiku | inherit
permissionMode: default              # Optional: Claude Code permission mode
skills: pr-review, security-check    # Optional: comma-separated skill names
# Calvin-specific fields (not in output):
scope: project                       # Optional: project | user
targets:                             # Optional: defaults to all
  - claude-code
---
```

### 4.3 Field Mapping

| Source (Calvin) | Output (Claude Code) | Notes |
|-----------------|----------------------|-------|
| `name` | `name` | Optional in source; defaults to filename |
| `description` | `description` | Required |
| `tools` | `tools` | Comma-separated string (matching Claude Code) |
| `model` | `model` | Same |
| `permissionMode` | `permissionMode` | camelCase (matching Claude Code) |
| `skills` | `skills` | Comma-separated string (matching Claude Code) |
| `scope` | (not output) | Calvin-only: determines output location |
| `targets` | (not output) | Calvin-only: determines which platforms |
| `kind` | (not output) | Auto-inferred from `agents/` directory |

### 4.4 Directory-Based Kind Inference

Files in `.promptpack/agents/` are automatically treated as `kind: agent`. Users do NOT need to specify `kind: agent` in frontmatter.

**Inference Rules:**
- `agents/*.md` → `kind: agent`
- `policies/*.md` → `kind: policy`  
- `actions/*.md` → `kind: action`
- `skills/*/SKILL.md` → `kind: skill`

If `kind:` is explicitly specified, it must match the directory (or error).

### 4.5 Backward Compatibility

For backward compatibility, Calvin also accepts the old format:
- `agent-tools:` as alias for `tools:`
- `agent-skills:` as alias for `skills:`
- `permission-mode:` as alias for `permissionMode:`
- Explicit `kind: agent` is still accepted (but optional for agents/ directory)

---

## 5. Technical Design

### 5.1 Model Layer Changes

#### 5.1.1 `src/models.rs` - Frontmatter

```rust
pub struct Frontmatter {
    // Existing fields...
    pub description: String,
    pub kind: AssetKind,
    pub scope: Scope,
    pub targets: Vec<Target>,
    pub apply: Option<String>,
    
    #[serde(default, rename = "allowed-tools")]
    pub allowed_tools: Vec<String>,  // Skill-only (existing)
    
    // NEW: Agent-specific fields
    #[serde(default, rename = "agent-tools")]
    pub agent_tools: Vec<String>,           // Agent tools whitelist
    
    #[serde(default)]
    pub model: Option<String>,              // Agent model override
    
    #[serde(default, rename = "permission-mode")]
    pub permission_mode: Option<String>,    // Agent permission mode
    
    #[serde(default, rename = "agent-skills")]
    pub agent_skills: Vec<String>,          // Agent pre-loaded skills
}
```

#### 5.1.2 `src/domain/entities/asset.rs` - Asset

```rust
pub struct Asset {
    // Existing fields...
    
    // NEW: Agent-specific fields
    agent_tools: Vec<String>,
    agent_model: Option<String>,
    agent_permission_mode: Option<String>,
    agent_skills: Vec<String>,
}

impl Asset {
    // NEW: Builder methods (matching existing pattern)
    pub fn with_agent_tools(mut self, tools: Vec<String>) -> Self {
        self.agent_tools = tools;
        self
    }
    
    pub fn with_agent_model(mut self, model: Option<String>) -> Self {
        self.agent_model = model;
        self
    }
    
    pub fn with_agent_permission_mode(mut self, mode: Option<String>) -> Self {
        self.agent_permission_mode = mode;
        self
    }
    
    pub fn with_agent_skills(mut self, skills: Vec<String>) -> Self {
        self.agent_skills = skills;
        self
    }
    
    // NEW: Getter methods
    pub fn agent_tools(&self) -> &[String] {
        &self.agent_tools
    }
    
    pub fn agent_model(&self) -> Option<&str> {
        self.agent_model.as_deref()
    }
    
    pub fn agent_permission_mode(&self) -> Option<&str> {
        self.agent_permission_mode.as_deref()
    }
    
    pub fn agent_skills(&self) -> &[String] {
        &self.agent_skills
    }
}
```

#### 5.1.3 `src/domain/entities/asset.rs` - From<PromptAsset> Update

**CRITICAL**: Must update the conversion to pass through agent fields.

```rust
impl From<crate::models::PromptAsset> for Asset {
    fn from(pa: crate::models::PromptAsset) -> Self {
        // ... existing conversion code ...
        
        // NEW: Handle agent-specific fields
        if !pa.frontmatter.agent_tools.is_empty() {
            asset = asset.with_agent_tools(pa.frontmatter.agent_tools);
        }
        if pa.frontmatter.model.is_some() {
            asset = asset.with_agent_model(pa.frontmatter.model);
        }
        if pa.frontmatter.permission_mode.is_some() {
            asset = asset.with_agent_permission_mode(pa.frontmatter.permission_mode);
        }
        if !pa.frontmatter.agent_skills.is_empty() {
            asset = asset.with_agent_skills(pa.frontmatter.agent_skills);
        }
        
        asset
    }
}
```

### 5.2 Infrastructure Layer Changes

#### 5.2.1 NEW: `src/infrastructure/adapters/agents.rs` - Shared Helper Module

**Following the `skills.rs` pattern exactly:**

```rust
//! Shared agent helpers for target adapters
//!
//! Reduces duplication across adapters by centralizing agent output generation.

use crate::domain::entities::Asset;
use crate::domain::ports::target_adapter::{AdapterDiagnostic, AdapterError, DiagnosticSeverity};

/// Serializable agent frontmatter for YAML output
#[derive(serde::Serialize)]
pub(crate) struct AgentFrontmatter<'a> {
    pub name: &'a str,
    pub description: &'a str,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tools: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub model: Option<&'a str>,
    #[serde(rename = "permissionMode", skip_serializing_if = "Option::is_none")]
    pub permission_mode: Option<&'a str>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub skills: Option<String>,
}

pub(crate) fn generate_agent_md(asset: &Asset, footer: &str) -> Result<String, AdapterError> {
    // Convert Vec<String> to comma-separated string for output
    let tools = if asset.agent_tools().is_empty() {
        None
    } else {
        Some(asset.agent_tools().join(", "))
    };
    
    let skills = if asset.agent_skills().is_empty() {
        None
    } else {
        Some(asset.agent_skills().join(", "))
    };
    
    let frontmatter = AgentFrontmatter {
        name: asset.id(),
        description: asset.description(),
        tools,
        model: asset.agent_model(),
        permission_mode: asset.agent_permission_mode(),
        skills,
    };

    let yaml = serde_yaml_ng::to_string(&frontmatter)
        .map_err(|e| AdapterError::CompilationFailed {
            message: format!(
                "Failed to serialize agent frontmatter for '{}': {}",
                asset.id(),
                e
            ),
        })?;

    let mut out = String::new();
    out.push_str("---\n");
    out.push_str(yaml.trim_end());
    out.push_str("\n---\n\n");
    out.push_str(asset.content().trim());
    out.push_str("\n\n");
    out.push_str(footer);

    Ok(out)
}

pub(crate) fn validate_agent_fields(asset: &Asset) -> Vec<AdapterDiagnostic> {
    let mut diags = Vec::new();
    
    // Validate model value
    if let Some(model) = asset.agent_model() {
        if !["sonnet", "opus", "haiku", "inherit"].contains(&model) {
            diags.push(AdapterDiagnostic {
                severity: DiagnosticSeverity::Warning,
                message: format!(
                    "Agent '{}' has invalid model '{}'. Valid values: sonnet, opus, haiku, inherit",
                    asset.id(),
                    model
                ),
            });
        }
    }
    
    // Validate permission mode value
    if let Some(mode) = asset.agent_permission_mode() {
        if !["default", "acceptEdits", "dontAsk", "bypassPermissions", "plan", "ignore"].contains(&mode) {
            diags.push(AdapterDiagnostic {
                severity: DiagnosticSeverity::Warning,
                message: format!(
                    "Agent '{}' has invalid permission-mode '{}'. Valid values: default, acceptEdits, dontAsk, bypassPermissions, plan, ignore",
                    asset.id(),
                    mode
                ),
            });
        }
    }
    
    // Warn on empty description
    if asset.description().trim().is_empty() {
        diags.push(AdapterDiagnostic {
            severity: DiagnosticSeverity::Warning,
            message: format!(
                "Agent '{}' has empty description. Claude Code uses description for auto-delegation routing.",
                asset.id()
            ),
        });
    }
    
    // Warn on long description (>500 chars affects routing performance)
    if asset.description().len() > 500 {
        diags.push(AdapterDiagnostic {
            severity: DiagnosticSeverity::Warning,
            message: format!(
                "Agent '{}' has description over 500 characters. This may affect Claude Code's routing performance.",
                asset.id()
            ),
        });
    }
    
    diags
}
```

#### 5.2.2 `src/infrastructure/adapters/claude_code.rs` - Update compile_agent

```rust
use super::agents;

fn compile_agent(&self, asset: &Asset) -> Result<Vec<OutputFile>, AdapterError> {
    let agents_dir = self.agents_dir(asset.scope());
    let agent_path = agents_dir.join(format!("{}.md", asset.id()));
    let footer = self.footer(&asset.source_path_normalized());

    let content = agents::generate_agent_md(asset, &footer)?;

    Ok(vec![OutputFile::new(agent_path, content, Target::ClaudeCode)])
}
```

Update `validate()` method to call `agents::validate_agent_fields()`.

#### 5.2.3 `src/infrastructure/adapters/mod.rs` - Register Module

```rust
pub mod agents;  // NEW
pub mod skills;
// ... existing modules
```

### 5.3 Domain Policy Module (Optional Validation)

#### 5.3.1 NEW: `src/domain/policies/agent_fields.rs`

```rust
//! Agent field validation policies

pub const VALID_MODELS: &[&str] = &["sonnet", "opus", "haiku", "inherit"];

pub const VALID_PERMISSION_MODES: &[&str] = &[
    "default",
    "acceptEdits", 
    "dontAsk",
    "bypassPermissions",
    "plan",
    "ignore",
];

pub fn is_valid_agent_model(model: &str) -> bool {
    VALID_MODELS.contains(&model)
}

pub fn is_valid_permission_mode(mode: &str) -> bool {
    VALID_PERMISSION_MODES.contains(&mode)
}
```

### 5.4 Other Platform Adapters

| Platform | Agent Handling |
|----------|----------------|
| **Cursor** | No native agent support. Compile to `.cursor/commands/` as fallback. Agent-specific fields (`tools`, `model`, etc.) are IGNORED. |
| **Antigravity** | Compile to `.agent/workflows/` (existing behavior). Agent-specific fields IGNORED. |
| **Codex** | Compile to `.codex/agents/` with similar frontmatter format. Reuse `agents::generate_agent_md()`. |
| **VSCode** | No agent support. Compile to `AGENTS.md` summary. Agent-specific fields shown in summary. |

---

## 6. Validation Rules

### 6.1 Source Validation (at parse time)

| Field | Validation |
|-------|------------|
| `agent-tools` | Accept as YAML list. No validation of tool names (advisory only in output validation). |
| `model` | Accept any string. Validate in output phase. |
| `permission-mode` | Accept any string. Validate in output phase. |
| `agent-skills` | Accept as YAML list. No validation (skill existence is runtime concern). |

### 6.2 Output Validation (in adapter)

| Check | Severity | Implementation |
|-------|----------|----------------|
| Invalid `model` value | Warning | `agents::validate_agent_fields()` |
| Invalid `permission-mode` value | Warning | `agents::validate_agent_fields()` |
| Empty description | Warning | `agents::validate_agent_fields()` |
| Description >500 chars | Warning | `agents::validate_agent_fields()` |
| Content empty | Warning | Existing validation |

---

## 7. Test Cases

### 7.1 Unit Tests - Frontmatter Parsing (`src/models.rs`)

```rust
#[test]
fn test_frontmatter_deserialize_agent_tools_as_list() {
    let yaml = r#"
description: Test agent
kind: agent
agent-tools:
  - Read
  - Grep
"#;
    let fm: Frontmatter = serde_yaml_ng::from_str(yaml).unwrap();
    assert_eq!(fm.agent_tools, vec!["Read", "Grep"]);
}

#[test]
fn test_frontmatter_deserialize_agent_model() {
    let yaml = r#"
description: Test agent
kind: agent
model: sonnet
"#;
    let fm: Frontmatter = serde_yaml_ng::from_str(yaml).unwrap();
    assert_eq!(fm.model, Some("sonnet".to_string()));
}

#[test]
fn test_frontmatter_deserialize_permission_mode_kebab_case() {
    let yaml = r#"
description: Test agent
kind: agent
permission-mode: acceptEdits
"#;
    let fm: Frontmatter = serde_yaml_ng::from_str(yaml).unwrap();
    assert_eq!(fm.permission_mode, Some("acceptEdits".to_string()));
}

#[test]
fn test_frontmatter_deserialize_agent_skills_as_list() {
    let yaml = r#"
description: Test agent
kind: agent
agent-skills:
  - skill-a
  - skill-b
"#;
    let fm: Frontmatter = serde_yaml_ng::from_str(yaml).unwrap();
    assert_eq!(fm.agent_skills, vec!["skill-a", "skill-b"]);
}

#[test]
fn test_frontmatter_agent_fields_ignored_for_non_agents() {
    let yaml = r#"
description: Test action
kind: action
agent-tools:
  - Read
"#;
    let fm: Frontmatter = serde_yaml_ng::from_str(yaml).unwrap();
    // Fields are parsed but will be ignored by adapter
    assert_eq!(fm.agent_tools, vec!["Read"]);
}
```

### 7.2 Unit Tests - Agent Output Generation (`src/infrastructure/adapters/agents.rs`)

```rust
#[test]
fn generate_agent_md_includes_yaml_frontmatter() {
    let asset = create_agent_asset("reviewer", "Code reviewer", "You review code.");
    let footer = "<!-- footer -->";
    
    let out = generate_agent_md(&asset, footer).unwrap();
    
    assert!(out.starts_with("---\n"));
    assert!(out.contains("name: reviewer"));
    assert!(out.contains("description: Code reviewer"));
    assert!(out.contains("---\n\nYou review code."));
    assert!(out.ends_with(footer));
}

#[test]
fn generate_agent_md_escapes_description_with_colon() {
    let asset = create_agent_asset("test", "Use when: reviewing code", "Content");
    let footer = "<!-- footer -->";
    
    let out = generate_agent_md(&asset, footer).unwrap();
    
    // Verify YAML is parseable (serde_yaml handles escaping)
    let parsed = crate::parser::extract_frontmatter(&out, Path::new("test.md")).unwrap();
    let fm = crate::parser::parse_frontmatter(&parsed.yaml, Path::new("test.md")).unwrap();
    assert_eq!(fm.description, "Use when: reviewing code");
}

#[test]
fn generate_agent_md_converts_tools_list_to_comma_separated() {
    let asset = create_agent_asset("test", "Test", "Content")
        .with_agent_tools(vec!["Read".to_string(), "Grep".to_string(), "Glob".to_string()]);
    let footer = "<!-- footer -->";
    
    let out = generate_agent_md(&asset, footer).unwrap();
    
    assert!(out.contains("tools: Read, Grep, Glob"));
}

#[test]
fn generate_agent_md_uses_camelcase_permission_mode() {
    let asset = create_agent_asset("test", "Test", "Content")
        .with_agent_permission_mode(Some("acceptEdits".to_string()));
    let footer = "<!-- footer -->";
    
    let out = generate_agent_md(&asset, footer).unwrap();
    
    assert!(out.contains("permissionMode: acceptEdits"));
}

#[test]
fn generate_agent_md_omits_empty_optional_fields() {
    let asset = create_agent_asset("simple", "Simple agent", "Content");
    let footer = "<!-- footer -->";
    
    let out = generate_agent_md(&asset, footer).unwrap();
    
    assert!(out.contains("name: simple"));
    assert!(out.contains("description: Simple agent"));
    assert!(!out.contains("tools:"));
    assert!(!out.contains("model:"));
    assert!(!out.contains("permissionMode:"));
    assert!(!out.contains("skills:"));
}

#[test]
fn generate_agent_md_with_all_fields() {
    let asset = create_agent_asset("full", "Full agent", "Content")
        .with_agent_tools(vec!["Read".to_string(), "Bash".to_string()])
        .with_agent_model(Some("sonnet".to_string()))
        .with_agent_permission_mode(Some("dontAsk".to_string()))
        .with_agent_skills(vec!["skill-a".to_string(), "skill-b".to_string()]);
    let footer = "<!-- footer -->";
    
    let out = generate_agent_md(&asset, footer).unwrap();
    
    assert!(out.contains("name: full"));
    assert!(out.contains("tools: Read, Bash"));
    assert!(out.contains("model: sonnet"));
    assert!(out.contains("permissionMode: dontAsk"));
    assert!(out.contains("skills: skill-a, skill-b"));
}

#[test]
fn generate_agent_md_yaml_is_parseable() {
    let asset = create_agent_asset("test", "Test: with colon", "Content\nwith\nnewlines")
        .with_agent_tools(vec!["Read".to_string()])
        .with_agent_model(Some("opus".to_string()));
    let footer = "<!-- footer -->";
    
    let out = generate_agent_md(&asset, footer).unwrap();
    
    // Must be valid YAML that can be re-parsed
    let parsed = crate::parser::extract_frontmatter(&out, Path::new("test.md")).unwrap();
    assert!(!parsed.yaml.is_empty());
}
```

### 7.3 Unit Tests - Validation (`src/infrastructure/adapters/agents.rs`)

```rust
#[test]
fn validate_agent_fields_warns_on_invalid_model() {
    let asset = create_agent_asset("test", "Test", "Content")
        .with_agent_model(Some("invalid".to_string()));
    
    let diags = validate_agent_fields(&asset);
    
    assert!(diags.iter().any(|d| d.message.contains("invalid model")));
}

#[test]
fn validate_agent_fields_warns_on_invalid_permission_mode() {
    let asset = create_agent_asset("test", "Test", "Content")
        .with_agent_permission_mode(Some("invalid".to_string()));
    
    let diags = validate_agent_fields(&asset);
    
    assert!(diags.iter().any(|d| d.message.contains("invalid permission-mode")));
}

#[test]
fn validate_agent_fields_warns_on_empty_description() {
    let asset = create_agent_asset("test", "", "Content");
    
    let diags = validate_agent_fields(&asset);
    
    assert!(diags.iter().any(|d| d.message.contains("empty description")));
}

#[test]
fn validate_agent_fields_warns_on_long_description() {
    let long_desc = "x".repeat(501);
    let asset = create_agent_asset("test", &long_desc, "Content");
    
    let diags = validate_agent_fields(&asset);
    
    assert!(diags.iter().any(|d| d.message.contains("500 characters")));
}

#[test]
fn validate_agent_fields_accepts_valid_values() {
    let asset = create_agent_asset("test", "Valid description", "Content")
        .with_agent_model(Some("sonnet".to_string()))
        .with_agent_permission_mode(Some("acceptEdits".to_string()));
    
    let diags = validate_agent_fields(&asset);
    
    assert!(diags.is_empty());
}
```

### 7.4 Integration Tests (`tests/cli_deploy_agents.rs`)

```rust
#[test]
fn deploy_agent_output_has_yaml_frontmatter() {
    let env = TestEnv::builder().build();
    
    env.write_project_file(
        ".promptpack/agents/reviewer.md",
        r#"---
kind: agent
description: Code reviewer agent
scope: project
targets: [claude-code]
---
You are a code reviewer.
"#,
    );
    
    let result = env.run(&["deploy", "--yes", "--targets", "claude-code"]);
    assert!(result.success);
    
    let content = std::fs::read_to_string(env.project_path(".claude/agents/reviewer.md")).unwrap();
    
    // Must start with YAML delimiter
    assert!(content.starts_with("---\n"), "Output must start with YAML frontmatter");
    
    // Must have name and description fields
    assert!(content.contains("name: reviewer"), "Must have name field matching ID");
    assert!(content.contains("description:"), "Must have description field");
}

#[test]
fn deploy_agent_yaml_frontmatter_is_parseable() {
    let env = TestEnv::builder().build();
    
    env.write_project_file(
        ".promptpack/agents/test.md",
        r#"---
kind: agent
description: "Test: with colon"
scope: project
targets: [claude-code]
---
Content
"#,
    );
    
    let result = env.run(&["deploy", "--yes", "--targets", "claude-code"]);
    assert!(result.success);
    
    let content = std::fs::read_to_string(env.project_path(".claude/agents/test.md")).unwrap();
    
    // Extract and parse frontmatter to verify it's valid YAML
    let extracted = calvin::parser::extract_frontmatter(&content, Path::new("test.md")).unwrap();
    let fm = calvin::parser::parse_frontmatter(&extracted.yaml, Path::new("test.md")).unwrap();
    
    assert_eq!(fm.description, "Test: with colon");
}

#[test]
fn deploy_agent_with_all_fields() {
    let env = TestEnv::builder().build();
    
    env.write_project_file(
        ".promptpack/agents/full.md",
        r#"---
kind: agent
description: Full agent
scope: project
targets: [claude-code]
agent-tools:
  - Read
  - Grep
model: sonnet
permission-mode: acceptEdits
agent-skills:
  - skill-a
  - skill-b
---
Content
"#,
    );
    
    let result = env.run(&["deploy", "--yes", "--targets", "claude-code"]);
    assert!(result.success);
    
    let content = std::fs::read_to_string(env.project_path(".claude/agents/full.md")).unwrap();
    
    assert!(content.contains("name: full"));
    assert!(content.contains("tools: Read, Grep"));
    assert!(content.contains("model: sonnet"));
    assert!(content.contains("permissionMode: acceptEdits"));
    assert!(content.contains("skills: skill-a, skill-b"));
}

#[test]
fn deploy_agent_warns_on_invalid_model() {
    let env = TestEnv::builder().build();
    
    env.write_project_file(
        ".promptpack/agents/bad.md",
        r#"---
kind: agent
description: Bad agent
scope: project
targets: [claude-code]
model: invalid-model
---
Content
"#,
    );
    
    let result = env.run(&["deploy", "--yes", "--targets", "claude-code"]);
    assert!(result.success); // Should succeed but warn
    
    assert!(
        result.combined_output().contains("invalid model") 
        || result.combined_output().contains("Warning"),
        "Should warn about invalid model"
    );
}

#[test]
fn deploy_cleanup_removes_orphaned_agent_files() {
    let env = TestEnv::builder().build();
    
    // Create and deploy agent
    env.write_project_file(
        ".promptpack/agents/temp.md",
        r#"---
kind: agent
description: Temp agent
scope: project
targets: [claude-code]
---
Content
"#,
    );
    env.run(&["deploy", "--yes", "--targets", "claude-code"]);
    assert!(env.project_path(".claude/agents/temp.md").exists());
    
    // Remove source and deploy with cleanup
    std::fs::remove_file(env.project_path(".promptpack/agents/temp.md")).unwrap();
    let result = env.run(&["deploy", "--yes", "--targets", "claude-code", "--cleanup"]);
    assert!(result.success);
    
    assert!(
        !env.project_path(".claude/agents/temp.md").exists(),
        "Orphaned agent file should be cleaned up"
    );
}

#[test]
fn layers_output_shows_agent_count() {
    let env = TestEnv::builder().build();
    
    env.write_project_file(
        ".promptpack/agents/one.md",
        r#"---
kind: agent
description: Agent one
---
Content
"#,
    );
    env.write_project_file(
        ".promptpack/agents/two.md",
        r#"---
kind: agent
description: Agent two
---
Content
"#,
    );
    
    let result = env.run(&["layers"]);
    assert!(result.success);
    
    // Should show agent count in output
    assert!(
        result.combined_output().contains("2 agents")
        || result.combined_output().contains("agents: 2"),
        "Should show agent count in layers output"
    );
}
```

### 7.5 Contract Tests (`tests/contracts/agents.rs`)

```rust
/// CONTRACT: Agent output files must have valid YAML frontmatter
#[test]
fn contract_agent_output_has_yaml_frontmatter() {
    let env = TestEnv::builder().build();
    
    env.write_project_file(
        ".promptpack/agents/test.md",
        r#"---
kind: agent
description: Test agent
targets: [claude-code]
---
Content
"#,
    );
    
    env.run(&["deploy", "--yes", "--targets", "claude-code"]);
    
    let content = env.read_deployed_file(".claude/agents/test.md");
    
    assert!(
        content.starts_with("---\n"),
        "CONTRACT: Agent output MUST start with YAML frontmatter delimiter"
    );
    assert!(
        content.contains("\n---\n"),
        "CONTRACT: Agent output MUST have closing YAML delimiter"
    );
}

/// CONTRACT: Agent name field must match filesystem ID
#[test]
fn contract_agent_name_matches_file_id() {
    let env = TestEnv::builder().build();
    
    env.write_project_file(
        ".promptpack/agents/my-agent.md",
        r#"---
kind: agent
description: Test agent
targets: [claude-code]
---
Content
"#,
    );
    
    env.run(&["deploy", "--yes", "--targets", "claude-code"]);
    
    let content = env.read_deployed_file(".claude/agents/my-agent.md");
    
    assert!(
        content.contains("name: my-agent"),
        "CONTRACT: Agent 'name' field MUST match the file ID (kebab-case)"
    );
}

/// CONTRACT: Agent description field must be present and non-empty
#[test]
fn contract_agent_description_present() {
    let env = TestEnv::builder().build();
    
    env.write_project_file(
        ".promptpack/agents/test.md",
        r#"---
kind: agent
description: My agent description
targets: [claude-code]
---
Content
"#,
    );
    
    env.run(&["deploy", "--yes", "--targets", "claude-code"]);
    
    let content = env.read_deployed_file(".claude/agents/test.md");
    
    assert!(
        content.contains("description: My agent description")
        || content.contains("description: \"My agent description\""),
        "CONTRACT: Agent 'description' field MUST be present in output"
    );
}

/// CONTRACT: permission-mode transforms to permissionMode (camelCase)
#[test]
fn contract_agent_permission_mode_camelcase() {
    let env = TestEnv::builder().build();
    
    env.write_project_file(
        ".promptpack/agents/test.md",
        r#"---
kind: agent
description: Test
targets: [claude-code]
permission-mode: acceptEdits
---
Content
"#,
    );
    
    env.run(&["deploy", "--yes", "--targets", "claude-code"]);
    
    let content = env.read_deployed_file(".claude/agents/test.md");
    
    assert!(
        content.contains("permissionMode: acceptEdits"),
        "CONTRACT: 'permission-mode' input MUST become 'permissionMode' (camelCase) in output"
    );
    assert!(
        !content.contains("permission-mode:"),
        "CONTRACT: Output MUST NOT contain kebab-case 'permission-mode'"
    );
}

/// CONTRACT: Optional fields are omitted when not set
#[test]
fn contract_agent_optional_fields_omitted() {
    let env = TestEnv::builder().build();
    
    env.write_project_file(
        ".promptpack/agents/minimal.md",
        r#"---
kind: agent
description: Minimal agent
targets: [claude-code]
---
Content
"#,
    );
    
    env.run(&["deploy", "--yes", "--targets", "claude-code"]);
    
    let content = env.read_deployed_file(".claude/agents/minimal.md");
    
    assert!(
        !content.contains("tools:"),
        "CONTRACT: 'tools' field MUST be omitted when not set"
    );
    assert!(
        !content.contains("model:"),
        "CONTRACT: 'model' field MUST be omitted when not set"
    );
    assert!(
        !content.contains("permissionMode:"),
        "CONTRACT: 'permissionMode' field MUST be omitted when not set"
    );
    assert!(
        !content.contains("skills:"),
        "CONTRACT: 'skills' field MUST be omitted when not set"
    );
}
```

---

## 8. Migration & Compatibility

### 8.1 Breaking Changes

**None for source format**. All new fields are optional.

### 8.2 Output Format Change

The generated `.claude/agents/*.md` files will change format:

| Before | After |
|--------|-------|
| Description first line | YAML frontmatter block |
| No structured metadata | `name`, `description`, etc. in frontmatter |

Users who have manual edits in `.claude/agents/` (not generated by Calvin) are unaffected.

### 8.3 Lockfile Impact

No changes to lockfile format. Agents are tracked the same way.

---

## 9. Documentation Updates

| Document | Changes |
|----------|---------|
| `docs/api/frontmatter.md` | Add agent-specific fields section (`agent-tools`, `model`, `permission-mode`, `agent-skills`) |
| `docs/target-platforms.md` | Update Claude Code agent output format |
| `CHANGELOG.md` | Document the format change |

**Documentation must include this warning:**

> **Subagent Skill Inheritance**: Subagents do NOT inherit skills from the main thread. If your subagent needs access to specific skills, you MUST list them in the `agent-skills:` field. Skills defined in CLAUDE.md or available to the main conversation are NOT automatically available to subagents.

---

## 10. Acceptance Criteria

### Must Have (P0) - ALL COMPLETE ✅

- [x] `generate_agent_md()` helper in `agents.rs` using serde for YAML generation
- [x] YAML output properly escapes descriptions with colons/special chars
- [x] `name` equals asset ID (kebab-case)
- [x] `description` from frontmatter, properly YAML-escaped
- [x] System prompt content appears after frontmatter
- [x] Footer comment preserved at end
- [x] `From<PromptAsset>` updated to pass through agent fields

### Should Have (P1) - ALL COMPLETE ✅

- [x] `agent-tools` field supported as YAML list → comma-separated output
- [x] `model` field supported with validation warning
- [x] `permission-mode` (source) → `permissionMode` (output) transform
- [x] `agent-skills` field supported as YAML list → comma-separated output
- [x] `validate_agent_fields()` function for adapter validation

### Nice to Have (P2) - ALL COMPLETE ✅

- [x] Warning for invalid model values (implemented in `validate_agent_fields()`)
- [x] Warning for invalid permission-mode values (implemented in `validate_agent_fields()`)
- [x] Warning for empty descriptions (implemented in `validate_agent_fields()`)
- [x] Warning for overly long descriptions (>500 chars) (implemented in `validate_agent_fields()`)
- [x] UI shows agent count in layer preview (added to `LayerSummary` and `layers` command output)

---

## 11. Resolved Design Decisions

| Question | Decision | Rationale |
|----------|----------|-----------|
| YAML serialization approach | Use `serde_yaml_ng` with struct, NOT manual string concat | Match skills.rs pattern, handle escaping correctly |
| `tools`/`skills` source format | YAML list (`Vec<String>`) | Match `allowed-tools` pattern, enable per-item validation |
| Field naming | `agent-tools`, `agent-skills` | Distinguish from skill's `allowed-tools`, make agent-specific nature explicit |
| `permission-mode` value format | Accept camelCase values (e.g., `acceptEdits`) | Match Claude Code spec values exactly |

---

## 12. Implementation Plan

### Phase 1: Core Format Fix (This PR)

1. Add agent-specific fields to `Frontmatter` (`agent-tools`, `model`, `permission-mode`, `agent-skills`)
2. Add agent-specific fields to `Asset` with builder/getter methods
3. Update `From<PromptAsset>` to pass through agent fields
4. Create `src/infrastructure/adapters/agents.rs` with `generate_agent_md()` and `validate_agent_fields()`
5. Update `ClaudeCodeAdapter::compile_agent()` to use new helper
6. Add unit tests for `agents.rs`
7. Update integration tests in `cli_deploy_agents.rs`
8. Add contract tests for output format
9. Run full test suite

### Phase 2: Enhanced Features (Future PR)

1. Update other adapters (Codex) to use `agents.rs` helper
2. Add agent count to `layers` command output
3. Add agent details to `calvin check` output
4. Update documentation

---

## Appendix A: Claude Code Tool Inventory

For reference, these are known Claude Code tools (subject to change):

- **File operations**: `Read`, `Write`, `Edit`, `Glob`, `Grep`
- **Execution**: `Bash`
- **Web**: `WebFetch`, `WebSearch`
- **System**: `Skill`, `SlashCommand`, `Task`
- **MCP tools**: Dynamically loaded from MCP servers

---

## Appendix B: Skill Implementation Reference

The agent implementation should mirror the skill implementation for consistency:

| Skill Pattern | Agent Equivalent |
|---------------|------------------|
| `skills.rs::SkillFrontmatter` | `agents.rs::AgentFrontmatter` |
| `skills.rs::generate_skill_md()` | `agents.rs::generate_agent_md()` |
| `skills.rs::validate_skill_allowed_tools()` | `agents.rs::validate_agent_fields()` |
| `Frontmatter.allowed_tools: Vec<String>` | `Frontmatter.agent_tools: Vec<String>` |

---

## Appendix C: Example Source and Output

### Source: `.promptpack/agents/researcher.md`

```markdown
---
description: Use proactively to explore the codebase and gather evidence before planning or editing.
kind: agent
agent-tools:
  - Read
  - Grep
  - Glob
  - Bash
model: haiku
permission-mode: default
agent-skills:
  - repo-navigation
---

You are a codebase researcher. You only discover and organize evidence; you do NOT make changes.

Your output must include:
- File paths you examined
- Search keywords/commands used
- Key snippets and why they matter

Minimize irrelevant information so the main thread can plan and execute efficiently.
```

### Output: `.claude/agents/researcher.md`

```markdown
---
name: researcher
description: Use proactively to explore the codebase and gather evidence before planning or editing.
tools: Read, Grep, Glob, Bash
model: haiku
permissionMode: default
skills: repo-navigation
---

You are a codebase researcher. You only discover and organize evidence; you do NOT make changes.

Your output must include:
- File paths you examined
- Search keywords/commands used
- Key snippets and why they matter

Minimize irrelevant information so the main thread can plan and execute efficiently.

<!-- Generated by Calvin. Source: agents/researcher.md. DO NOT EDIT. -->
```
