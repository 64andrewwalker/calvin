use crate::helpers::*;

// === Test Variants: Input Boundaries ===
// Using double underscore to mark variant tests per test-variants spec

#[test]
#[allow(non_snake_case)]
fn clean__with_empty_lockfile() {
    let env = fresh_env();

    write_legacy_lockfile(&env, "version = 1\n\n[files]\n");
    write_project_config(&env, "[deploy]\ntarget = \"project\"\n");

    let result = env.run(&["clean", "--project", "--yes"]);

    assert!(
        result.success,
        "clean should succeed with empty lockfile:\n{}",
        result.combined_output()
    );
}

#[test]
#[allow(non_snake_case)]
fn clean__with_nonexistent_source() {
    let env = fresh_env();
    let result = env.run(&[
        "clean",
        "--source",
        "/nonexistent/path",
        "--project",
        "--yes",
    ]);

    let combined = result.combined_output().to_lowercase();
    assert!(
        !result.success || combined.contains("no ") || combined.contains("lockfile"),
        "Should indicate missing source or lockfile.\nOutput:\n{}",
        result.combined_output()
    );
}

#[test]
#[allow(non_snake_case)]
fn clean__conflicting_scope_flags() {
    let env = fresh_env();
    let result = env.run(&["clean", "--home", "--project"]);

    assert!(
        !result.success,
        "--home and --project should conflict.\nOutput:\n{}",
        result.combined_output()
    );
}

// === Test Variants: State Variations ===

#[test]
#[allow(non_snake_case)]
fn clean__with_already_deleted_files() {
    let env = fresh_env();

    let missing_file = env.project_path(".cursor/rules/missing.mdc");
    write_legacy_lockfile(
        &env,
        &format!(
            r#"version = 1

[files."project:{}"]
hash = "sha256:somehash"
"#,
            normalize_path_for_key(&missing_file)
        ),
    );
    write_project_config(&env, "[deploy]\ntarget = \"project\"\n");

    let result = env.run(&["clean", "--project", "--yes"]);

    assert!(
        result.success,
        "clean should succeed with missing files:\n{}",
        result.combined_output()
    );

    assert!(
        result.stdout.contains("skipped") || result.stdout.contains("0 files deleted"),
        "Should show skipped or 0 deleted.\nstdout:\n{}",
        result.stdout
    );
}

#[test]
#[allow(non_snake_case)]
fn clean__with_mixed_scope_entries() {
    let env = fresh_env();

    let project_file = env.project_path(".cursor/rules/project.mdc");
    let file_content = "<!-- Generated by Calvin -->\nProject content";
    env.write_project_file(".cursor/rules/project.mdc", file_content);

    let hash = sha256_hash(file_content);
    write_legacy_lockfile(
        &env,
        &format!(
            r#"version = 1

[files."project:{}"]
hash = "{}"

[files."home:~/.claude/commands/home-file.md"]
hash = "sha256:homefilehash"
"#,
            normalize_path_for_key(&project_file),
            hash
        ),
    );
    write_project_config(&env, "[deploy]\ntarget = \"project\"\n");

    let result = env.run(&["clean", "--project", "--yes"]);
    assert!(
        result.success,
        "clean --project should succeed:\n{}",
        result.combined_output()
    );

    assert!(!project_file.exists(), "Project file should be deleted");
}

// === Test Variants: Error Injection ===

#[test]
#[allow(non_snake_case)]
fn clean__with_file_without_signature() {
    let env = fresh_env();

    let relative = ".cursor/rules/nosig.mdc";
    let file = env.project_path(relative);
    let file_content = "User created content without signature";
    env.write_project_file(relative, file_content);

    let hash = sha256_hash(file_content);
    write_legacy_lockfile(
        &env,
        &format!(
            r#"version = 1

[files."project:{}"]
hash = "{}"
"#,
            normalize_path_for_key(&file),
            hash
        ),
    );
    write_project_config(&env, "[deploy]\ntarget = \"project\"\n");

    let result = env.run(&["clean", "--project", "--yes"]);

    assert!(
        result.success,
        "clean should succeed:\n{}",
        result.combined_output()
    );
    assert!(
        file.exists(),
        "File without signature should not be deleted"
    );
}

#[test]
#[allow(non_snake_case)]
fn clean__with_force_deletes_unsigned_file() {
    let env = fresh_env();

    let relative = ".cursor/rules/nosig.mdc";
    let file = env.project_path(relative);
    let file_content = "User created content without signature";
    env.write_project_file(relative, file_content);

    let hash = sha256_hash(file_content);
    write_legacy_lockfile(
        &env,
        &format!(
            r#"version = 1

[files."project:{}"]
hash = "{}"
"#,
            normalize_path_for_key(&file),
            hash
        ),
    );
    write_project_config(&env, "[deploy]\ntarget = \"project\"\n");

    let result = env.run(&["clean", "--project", "--yes", "--force"]);

    assert!(
        result.success,
        "clean --force should succeed:\n{}",
        result.combined_output()
    );
    assert!(!file.exists(), "File should be deleted with --force");
}

#[test]
#[allow(non_snake_case)]
fn clean__with_modified_file() {
    let env = fresh_env();

    let relative = ".cursor/rules/modified.mdc";
    let file = env.project_path(relative);
    env.write_project_file(relative, "<!-- Generated by Calvin -->\nModified content");

    write_legacy_lockfile(
        &env,
        &format!(
            r#"version = 1

[files."project:{}"]
hash = "sha256:originalhashbeforemodification1234567890abcdef"
"#,
            normalize_path_for_key(&file)
        ),
    );
    write_project_config(&env, "[deploy]\ntarget = \"project\"\n");

    let result = env.run(&["clean", "--project", "--yes"]);
    assert!(
        result.success,
        "clean should succeed:\n{}",
        result.combined_output()
    );

    assert!(file.exists(), "Modified file should not be deleted");
    assert!(
        result.stdout.contains("skipped"),
        "Should indicate file was skipped"
    );
}

// === Test Variants: Output Format ===

#[test]
#[allow(non_snake_case)]
fn clean__dry_run_shows_would_be_deleted() {
    let env = deployed_project_env();
    let result = env.run(&["clean", "--project", "--dry-run"]);

    assert!(
        result.success,
        "clean --dry-run should succeed:\n{}",
        result.combined_output()
    );

    let stdout = result.stdout.to_lowercase();
    assert!(
        stdout.contains("would") || stdout.contains("dry") || stdout.contains("preview"),
        "Dry run output should indicate preview mode"
    );
}
